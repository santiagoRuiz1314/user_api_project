>>>> Dockerfile

>>>> README.md
# Clients-API


>>>> app/controllers/user_controller.py
from app.use_cases.user.create_user import create_user_use_case
from app.use_cases.user.login_user import login_user_use_case
from app.use_cases.user.get_user_by_id import get_user_by_id_use_case
from app.use_cases.user.list_users import list_users_use_case
from app.use_cases.user.update_user import update_user_use_case
from app.use_cases.user.delete_user import delete_user_use_case
from app.interfaces.schemas.user_request import (
    UserCreateRequest,
    UserLoginRequest,
    UserUpdateRequest,
    UserQueryRequest
)

class UserController:
    def __init__(self):
        self.create_user_use_case = create_user_use_case
        self.login_user_use_case = login_user_use_case
        self.get_user_by_id_use_case = get_user_by_id_use_case
        self.list_users_use_case = list_users_use_case
        self.update_user_use_case = update_user_use_case
        self.delete_user_use_case = delete_user_use_case

    async def create_user(self, request: UserCreateRequest):
        user = await self.create_user_use_case.execute(request.email, request.password)
        return {"user": user, "message": "Usuario creado exitosamente"}

    async def login_user(self, request: UserLoginRequest):
        token, user = await self.login_user_use_case.execute(request.email, request.password)
        from app.core.security import create_token_response_data
        return create_token_response_data(token, user) | {"user": user}

    async def get_user_by_id(self, user_id: str, current_user):
        return await self.get_user_by_id_use_case.execute(user_id, current_user.id)

    async def list_users(self, query: UserQueryRequest, current_user):
        users, total = await self.list_users_use_case.execute(
            requesting_user_id=current_user.id,
            skip=query.skip,
            limit=query.limit
        )
        from app.interfaces.schemas.user_response import users_to_list_response
        return users_to_list_response(users, total, query.skip, query.limit)

    async def update_user(self, user_id: str, request: UserUpdateRequest, current_user):
        user = await self.update_user_use_case.execute(
            user_id=user_id,
            requesting_user_id=current_user.id,
            new_email=request.email,
            new_password=request.password
        )
        return {"user": user, "message": "Usuario actualizado exitosamente"}

    async def delete_user_soft(self, user_id: str, current_user):
        user = await self.delete_user_use_case.execute_soft_delete(user_id, current_user.id)
        return {"message": "Usuario desactivado exitosamente", "deleted_id": user.id}

    async def delete_user_hard(self, user_id: str, current_user):
        deleted_id = await self.delete_user_use_case.execute_hard_delete(user_id, current_user.id)
        return {"message": "Usuario eliminado permanentemente", "deleted_id": deleted_id}

    async def reactivate_user(self, user_id: str, current_user):
        user = await self.delete_user_use_case.reactivate_user(user_id, current_user.id)
        return {"user": user, "message": "Usuario reactivado exitosamente"}

# Instancia global
user_controller = UserController()

>>>> app/core/config.py
"""
Configuración central de la aplicación.
Maneja variables de entorno y configuraciones generales.
"""
from typing import Optional
import os

class Settings:
    """Configuraciones de la aplicación."""
    
    # JWT Configuration
    JWT_SECRET_KEY: str = os.getenv("JWT_SECRET_KEY", "your-secret-key-change-in-production")
    JWT_ALGORITHM: str = "HS256"
    JWT_EXPIRATION_TIME_MINUTES: int = int(os.getenv("JWT_EXPIRATION_TIME_MINUTES", "30"))
    
    # API Configuration
    API_V1_PREFIX: str = "/api/v1"
    PROJECT_NAME: str = "Clients API"
    PROJECT_VERSION: str = "1.0.0"
    
    # CORS Configuration
    ALLOWED_ORIGINS: list = ["*"]  # En producción, especificar dominios exactos
    
    # MongoDB Configuration (para futuro uso)
    MONGODB_URL: Optional[str] = os.getenv("MONGODB_URL")
    DATABASE_NAME: str = os.getenv("DATABASE_NAME", "clients_db")
    
    # Environment
    ENVIRONMENT: str = os.getenv("ENVIRONMENT", "development")
    DEBUG: bool = ENVIRONMENT == "development"

# Instancia global de configuración
settings = Settings()
>>>> app/core/exception_handlers.py
"""
Manejadores de excepciones centralizados.
Convierte excepciones del dominio en respuestas HTTP apropiadas.
"""
from fastapi import Request, HTTPException, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from pydantic import ValidationError
import logging
from datetime import datetime
from app.core.exceptions import (
    DomainException,
    ValidationException,
    AuthenticationException,
    AuthorizationException,
    NotFoundException,
    ConflictException,
    BusinessRuleException,
    InfrastructureException,
    UserAlreadyExistsException,
    UserNotFoundException,
    UserInactiveException,
    InvalidCredentialsException,
    TokenExpiredException,
    InvalidTokenException
)

# Configurar logger
logger = logging.getLogger(__name__)

class ExceptionHandler:
    """Manejador centralizado de excepciones."""
    
    @staticmethod
    def create_error_response(
        status_code: int,
        message: str,
        error_code: str = None,
        details: dict = None,
        path: str = None
    ) -> JSONResponse:
        """
        Crea una respuesta de error estándar.
        
        Args:
            status_code: Código de estado HTTP
            message: Mensaje de error
            error_code: Código de error interno
            details: Detalles adicionales del error
            path: Ruta donde ocurrió el error
            
        Returns:
            JSONResponse con formato estándar de error
        """
        error_data = {
            "error": True,
            "message": message,
            "status_code": status_code,
            "timestamp": datetime.utcnow().isoformat(),
        }
        
        if error_code:
            error_data["error_code"] = error_code
        
        if details:
            error_data["details"] = details
        
        if path:
            error_data["path"] = path
        
        return JSONResponse(
            status_code=status_code,
            content=error_data
        )

# Manejadores específicos para cada tipo de excepción
async def domain_exception_handler(request: Request, exc: DomainException):
    """Manejador para excepciones generales del dominio."""
    logger.warning(f"Domain exception: {exc.message}")
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_400_BAD_REQUEST,
        message=exc.message,
        error_code=exc.error_code,
        path=str(request.url)
    )

async def validation_exception_handler(request: Request, exc: ValidationException):
    """Manejador para errores de validación."""
    logger.info(f"Validation error: {exc.message}")
    
    details = {}
    if exc.field:
        details["field"] = exc.field
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_400_BAD_REQUEST,
        message=exc.message,
        error_code=exc.error_code,
        details=details if details else None,
        path=str(request.url)
    )

async def authentication_exception_handler(request: Request, exc: AuthenticationException):
    """Manejador para errores de autenticación."""
    logger.info(f"Authentication error: {exc.message}")
    
    headers = {"WWW-Authenticate": "Bearer"}
    
    response = ExceptionHandler.create_error_response(
        status_code=status.HTTP_401_UNAUTHORIZED,
        message=exc.message,
        error_code=exc.error_code,
        path=str(request.url)
    )
    
    response.headers.update(headers)
    return response

async def authorization_exception_handler(request: Request, exc: AuthorizationException):
    """Manejador para errores de autorización."""
    logger.warning(f"Authorization error: {exc.message}")
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_403_FORBIDDEN,
        message=exc.message,
        error_code=exc.error_code,
        path=str(request.url)
    )

async def not_found_exception_handler(request: Request, exc: NotFoundException):
    """Manejador para recursos no encontrados."""
    logger.info(f"Resource not found: {exc.message}")
    
    details = {}
    if exc.resource:
        details["resource"] = exc.resource
    if exc.identifier:
        details["identifier"] = exc.identifier
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_404_NOT_FOUND,
        message=exc.message,
        error_code=exc.error_code,
        details=details if details else None,
        path=str(request.url)
    )

async def conflict_exception_handler(request: Request, exc: ConflictException):
    """Manejador para conflictos de recursos."""
    logger.info(f"Resource conflict: {exc.message}")
    
    details = {}
    if exc.resource:
        details["resource"] = exc.resource
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_409_CONFLICT,
        message=exc.message,
        error_code=exc.error_code,
        details=details if details else None,
        path=str(request.url)
    )

async def business_rule_exception_handler(request: Request, exc: BusinessRuleException):
    """Manejador para violaciones de reglas de negocio."""
    logger.warning(f"Business rule violation: {exc.message}")
    
    details = {}
    if exc.rule:
        details["rule"] = exc.rule
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        message=exc.message,
        error_code=exc.error_code,
        details=details if details else None,
        path=str(request.url)
    )

async def infrastructure_exception_handler(request: Request, exc: InfrastructureException):
    """Manejador para errores de infraestructura."""
    logger.error(f"Infrastructure error: {exc.message}")
    
    details = {}
    if exc.component:
        details["component"] = exc.component
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        message="Error interno del sistema",  # No exponer detalles internos
        error_code=exc.error_code,
        details=details if details else None,
        path=str(request.url)
    )

# Manejadores para excepciones estándar de FastAPI
async def http_exception_handler(request: Request, exc: HTTPException):
    """Manejador para excepciones HTTP de FastAPI."""
    logger.info(f"HTTP exception: {exc.detail}")
    
    return ExceptionHandler.create_error_response(
        status_code=exc.status_code,
        message=exc.detail,
        path=str(request.url)
    )

async def request_validation_exception_handler(request: Request, exc: RequestValidationError):
    """Manejador para errores de validación de requests."""
    logger.info(f"Request validation error: {exc.errors()}")
    
    # Formatear errores de validación de Pydantic
    errors = []
    for error in exc.errors():
        field = " -> ".join(str(loc) for loc in error["loc"])
        errors.append({
            "field": field,
            "message": error["msg"],
            "type": error["type"]
        })
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        message="Datos de entrada inválidos",
        error_code="VALIDATION_ERROR",
        details={"validation_errors": errors},
        path=str(request.url)
    )

async def general_exception_handler(request: Request, exc: Exception):
    """Manejador para excepciones generales no capturadas."""
    logger.error(f"Unhandled exception: {str(exc)}", exc_info=True)
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        message="Error interno del servidor",
        error_code="INTERNAL_ERROR",
        path=str(request.url)
    )

# Diccionario con todos los manejadores
EXCEPTION_HANDLERS = {
    # Excepciones del dominio
    ValidationException: validation_exception_handler,
    AuthenticationException: authentication_exception_handler,
    AuthorizationException: authorization_exception_handler,
    NotFoundException: not_found_exception_handler,
    ConflictException: conflict_exception_handler,
    BusinessRuleException: business_rule_exception_handler,
    InfrastructureException: infrastructure_exception_handler,
    DomainException: domain_exception_handler,
    
    # Excepciones específicas de usuarios
    UserAlreadyExistsException: conflict_exception_handler,
    UserNotFoundException: not_found_exception_handler,
    UserInactiveException: business_rule_exception_handler,
    InvalidCredentialsException: authentication_exception_handler,
    TokenExpiredException: authentication_exception_handler,
    InvalidTokenException: authentication_exception_handler,
    
    # Excepciones estándar de FastAPI
    HTTPException: http_exception_handler,
    RequestValidationError: request_validation_exception_handler,
    
    # Excepción general
    Exception: general_exception_handler,
}
>>>> app/core/exceptions.py
"""
Excepciones personalizadas para la aplicación.
Define excepciones específicas del dominio para mejor manejo de errores.
"""

class DomainException(Exception):
    """Excepción base para errores del dominio."""
    
    def __init__(self, message: str, error_code: str = None):
        super().__init__(message)
        self.message = message
        self.error_code = error_code


class ValidationException(DomainException):
    """Excepción para errores de validación."""
    
    def __init__(self, message: str, field: str = None):
        super().__init__(message, "VALIDATION_ERROR")
        self.field = field


class AuthenticationException(DomainException):
    """Excepción para errores de autenticación."""
    
    def __init__(self, message: str = "Credenciales inválidas"):
        super().__init__(message, "AUTHENTICATION_ERROR")


class AuthorizationException(DomainException):
    """Excepción para errores de autorización."""
    
    def __init__(self, message: str = "No tienes permisos para esta operación"):
        super().__init__(message, "AUTHORIZATION_ERROR")


class NotFoundException(DomainException):
    """Excepción para recursos no encontrados."""
    
    def __init__(self, resource: str, identifier: str = None):
        if identifier:
            message = f"{resource} con ID '{identifier}' no encontrado"
        else:
            message = f"{resource} no encontrado"
        super().__init__(message, "NOT_FOUND")
        self.resource = resource
        self.identifier = identifier


class ConflictException(DomainException):
    """Excepción para conflictos de recursos."""
    
    def __init__(self, message: str, resource: str = None):
        super().__init__(message, "CONFLICT")
        self.resource = resource


class BusinessRuleException(DomainException):
    """Excepción para violaciones de reglas de negocio."""
    
    def __init__(self, message: str, rule: str = None):
        super().__init__(message, "BUSINESS_RULE_VIOLATION")
        self.rule = rule


class InfrastructureException(DomainException):
    """Excepción para errores de infraestructura."""
    
    def __init__(self, message: str, component: str = None):
        super().__init__(message, "INFRASTRUCTURE_ERROR")
        self.component = component


# Excepciones específicas del dominio de usuarios
class UserAlreadyExistsException(ConflictException):
    """Excepción cuando un usuario ya existe."""
    
    def __init__(self, email: str):
        super().__init__(f"Usuario con email '{email}' ya existe", "User")
        self.email = email


class UserNotFoundException(NotFoundException):
    """Excepción cuando un usuario no se encuentra."""
    
    def __init__(self, identifier: str = None):
        super().__init__("Usuario", identifier)


class UserInactiveException(BusinessRuleException):
    """Excepción cuando un usuario está inactivo."""
    
    def __init__(self, user_id: str = None):
        message = "Usuario inactivo"
        if user_id:
            message = f"Usuario con ID '{user_id}' está inactivo"
        super().__init__(message, "user_active_required")


class InvalidCredentialsException(AuthenticationException):
    """Excepción para credenciales inválidas."""
    
    def __init__(self):
        super().__init__("Email o contraseña incorrectos")


class TokenExpiredException(AuthenticationException):
    """Excepción para tokens expirados."""
    
    def __init__(self):
        super().__init__("Token expirado")


class InvalidTokenException(AuthenticationException):
    """Excepción para tokens inválidos."""
    
    def __init__(self):
        super().__init__("Token inválido")
>>>> app/core/security.py
"""
Configuración de seguridad y autenticación JWT.
Maneja la verificación de tokens y dependencias de autenticación.
"""
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from typing import Optional
from app.infrastructure.auth.jwt_handler import jwt_handler
from app.infrastructure.db.user_model import user_model
from app.domain.user.user_entity import User

# Esquema de seguridad Bearer Token
security = HTTPBearer()

class SecurityService:
    """Servicio de seguridad para autenticación y autorización."""
    
    @staticmethod
    async def get_current_user(
        credentials: HTTPAuthorizationCredentials = Depends(security)
    ) -> User:
        """
        Dependency para obtener el usuario actual autenticado.
        
        Args:
            credentials: Credenciales JWT del header Authorization
            
        Returns:
            Entidad User del usuario autenticado
            
        Raises:
            HTTPException: Si el token es inválido o el usuario no existe
        """
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        
        try:
            # Verificar y decodificar token
            payload = jwt_handler.verify_token(credentials.credentials)
            if payload is None:
                raise credentials_exception
            
            user_id: str = payload.get("user_id")
            if user_id is None:
                raise credentials_exception
            
        except Exception:
            raise credentials_exception
        
        # Buscar usuario en la base de datos
        user = await user_model.get_by_id(user_id)
        if user is None:
            raise credentials_exception
        
        # Verificar que el usuario esté activo
        if not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Inactive user"
            )
        
        return user
    
    @staticmethod
    async def get_current_active_user(
        current_user: User = Depends(get_current_user)
    ) -> User:
        """
        Dependency para obtener el usuario actual activo.
        Es un wrapper adicional para mayor claridad en los endpoints.
        
        Args:
            current_user: Usuario actual obtenido del token
            
        Returns:
            Entidad User del usuario activo
            
        Raises:
            HTTPException: Si el usuario está inactivo
        """
        if not current_user.is_active:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Inactive user"
            )
        return current_user
    
    @staticmethod
    def verify_token_without_exception(token: str) -> Optional[dict]:
        """
        Verifica un token JWT sin lanzar excepciones.
        Útil para casos donde necesitamos verificar tokens opcionalmente.
        
        Args:
            token: Token JWT a verificar
            
        Returns:
            Payload del token si es válido, None si es inválido
        """
        return jwt_handler.verify_token(token)
    
    @staticmethod
    async def get_user_from_token(token: str) -> Optional[User]:
        """
        Obtiene un usuario directamente desde un token JWT.
        
        Args:
            token: Token JWT
            
        Returns:
            Entidad User si el token es válido y el usuario existe, None en caso contrario
        """
        payload = SecurityService.verify_token_without_exception(token)
        if not payload:
            return None
        
        user_id = payload.get("user_id")
        if not user_id:
            return None
        
        user = await user_model.get_by_id(user_id)
        if not user or not user.is_active:
            return None
        
        return user

# Instancia global del servicio de seguridad
security_service = SecurityService()

# Función de conveniencia para dependency injection
async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> User:
    """Dependency function para obtener el usuario actual."""
    return await security_service.get_current_user(credentials)

async def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """Dependency function para obtener el usuario actual activo."""
    return await security_service.get_current_active_user(current_user)

# Funciones adicionales de utilidad
def create_token_response_data(token: str, user: User) -> dict:
    """
    Crea los datos de respuesta para un token JWT.
    
    Args:
        token: Token JWT generado
        user: Entidad User
        
    Returns:
        Diccionario con datos del token y usuario
    """
    from app.core.config import settings
    
    return {
        "access_token": token,
        "token_type": "bearer",
        "expires_in": settings.JWT_EXPIRATION_TIME_MINUTES,
        "user_id": user.id,
        "email": user.email
    }
>>>> app/core/utils.py
"""
Funciones auxiliares generales.
Funciones de utilidad que se usan en toda la aplicación.
"""
import re
from datetime import datetime
from typing import Any, Dict, Optional
import uuid

class ValidationUtils:
    """Utilidades para validación de datos."""
    
    @staticmethod
    def is_valid_email(email: str) -> bool:
        """
        Valida si un email tiene formato correcto.
        
        Args:
            email: Email a validar
            
        Returns:
            True si es válido, False en caso contrario
        """
        if not email:
            return False
        
        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(email_pattern, email) is not None
    
    @staticmethod
    def is_valid_password(password: str) -> bool:
        """
        Valida si una contraseña cumple los requisitos mínimos.
        
        Args:
            password: Contraseña a validar
            
        Returns:
            True si es válida, False en caso contrario
        """
        if not password:
            return False
        
        return len(password) >= 6 and len(password) <= 128
    
    @staticmethod
    def is_valid_uuid(uuid_string: str) -> bool:
        """
        Valida si un string es un UUID válido.
        
        Args:
            uuid_string: String a validar
            
        Returns:
            True si es un UUID válido, False en caso contrario
        """
        try:
            uuid.UUID(uuid_string)
            return True
        except ValueError:
            return False

class DateUtils:
    """Utilidades para manejo de fechas."""
    
    @staticmethod
    def get_current_utc() -> datetime:
        """
        Obtiene la fecha y hora actual en UTC.
        
        Returns:
            Datetime actual en UTC
        """
        return datetime.utcnow()
    
    @staticmethod
    def format_datetime(dt: datetime) -> str:
        """
        Formatea un datetime a string ISO.
        
        Args:
            dt: Datetime a formatear
            
        Returns:
            String en formato ISO
        """
        return dt.isoformat()
    
    @staticmethod
    def parse_datetime(dt_string: str) -> Optional[datetime]:
        """
        Parsea un string de fecha a datetime.
        
        Args:
            dt_string: String de fecha en formato ISO
            
        Returns:
            Datetime parseado o None si es inválido
        """
        try:
            return datetime.fromisoformat(dt_string)
        except ValueError:
            return None

class ResponseUtils:
    """Utilidades para manejo de respuestas de API."""
    
    @staticmethod
    def success_response(
        message: str = "Operation successful",
        data: Optional[Any] = None
    ) -> Dict[str, Any]:
        """
        Crea una respuesta de éxito estándar.
        
        Args:
            message: Mensaje de éxito
            data: Datos adicionales (opcional)
            
        Returns:
            Diccionario con respuesta de éxito
        """
        response = {
            "success": True,
            "message": message,
            "timestamp": DateUtils.get_current_utc().isoformat()
        }
        
        if data is not None:
            response["data"] = data
        
        return response
    
    @staticmethod
    def error_response(
        message: str,
        error_code: Optional[str] = None,
        details: Optional[Any] = None
    ) -> Dict[str, Any]:
        """
        Crea una respuesta de error estándar.
        
        Args:
            message: Mensaje de error
            error_code: Código de error (opcional)
            details: Detalles adicionales (opcional)
            
        Returns:
            Diccionario con respuesta de error
        """
        response = {
            "success": False,
            "error": message,
            "timestamp": DateUtils.get_current_utc().isoformat()
        }
        
        if error_code:
            response["error_code"] = error_code
        
        if details:
            response["details"] = details
        
        return response

class StringUtils:
    """Utilidades para manejo de strings."""
    
    @staticmethod
    def normalize_email(email: str) -> str:
        """
        Normaliza un email (lowercase y trim).
        
        Args:
            email: Email a normalizar
            
        Returns:
            Email normalizado
        """
        if not email:
            return ""
        
        return email.lower().strip()
    
    @staticmethod
    def generate_uuid() -> str:
        """
        Genera un UUID único.
        
        Returns:
            UUID como string
        """
        return str(uuid.uuid4())
    
    @staticmethod
    def sanitize_string(text: str, max_length: int = 255) -> str:
        """
        Sanitiza un string eliminando caracteres no deseados.
        
        Args:
            text: Texto a sanitizar
            max_length: Longitud máxima
            
        Returns:
            String sanitizado
        """
        if not text:
            return ""
        
        # Trim y limitar longitud
        sanitized = text.strip()[:max_length]
        
        return sanitized

class PaginationUtils:
    """Utilidades para paginación."""
    
    @staticmethod
    def validate_pagination_params(skip: int, limit: int) -> tuple[int, int]:
        """
        Valida y normaliza parámetros de paginación.
        
        Args:
            skip: Registros a saltar
            limit: Límite de registros
            
        Returns:
            Tupla con (skip, limit) validados
        """
        # Validar skip
        if skip < 0:
            skip = 0
        
        # Validar limit
        if limit < 1:
            limit = 20
        elif limit > 100:
            limit = 100
        
        return skip, limit
    
    @staticmethod
    def calculate_pagination_info(
        total: int,
        skip: int,
        limit: int,
        current_count: int
    ) -> Dict[str, Any]:
        """
        Calcula información de paginación.
        
        Args:
            total: Total de registros
            skip: Registros saltados
            limit: Límite de registros
            current_count: Registros en la página actual
            
        Returns:
            Diccionario con información de paginación
        """
        has_more = skip + current_count < total
        current_page = (skip // limit) + 1
        total_pages = (total + limit - 1) // limit  # Ceiling division
        
        return {
            "total": total,
            "skip": skip,
            "limit": limit,
            "current_count": current_count,
            "has_more": has_more,
            "current_page": current_page,
            "total_pages": total_pages
        }

# Instancias globales de utilidades
validation_utils = ValidationUtils()
date_utils = DateUtils()
response_utils = ResponseUtils()
string_utils = StringUtils()
pagination_utils = PaginationUtils()
>>>> app/domain/user/user_entity.py
from datetime import datetime
from typing import Optional
from app.core.utils import string_utils, date_utils

class User:
    def __init__(self, id: str, email: str, password_hash: str,
                 is_active: bool = True,
                 created_at: Optional[datetime] = None,
                 updated_at: Optional[datetime] = None):
        self.id = id
        self.email = email
        self.password_hash = password_hash
        self.is_active = is_active
        self.created_at = created_at or date_utils.get_current_utc()
        self.updated_at = updated_at or date_utils.get_current_utc()

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "email": self.email,
            "password_hash": self.password_hash,
            "is_active": self.is_active,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }

    @classmethod
    def from_dict(cls, data: dict) -> "User":
        return cls(
            id=data["id"],
            email=data["email"],
            password_hash=data["password_hash"],
            is_active=data.get("is_active", True),
            created_at=date_utils.parse_datetime(data.get("created_at")),
            updated_at=date_utils.parse_datetime(data.get("updated_at"))
        )

    @classmethod
    def create_new_user(cls, email: str, password_hash: str) -> "User":
        return cls(
            id=string_utils.generate_uuid(),
            email=email,
            password_hash=password_hash
        )

    def deactivate(self):
        """Desactiva el usuario (soft delete)"""
        self.is_active = False
        self.updated_at = date_utils.get_current_utc()

    def activate(self):
        """Activa el usuario"""
        self.is_active = True
        self.updated_at = date_utils.get_current_utc()

    def update_email(self, new_email: str):
        """Actualiza el email del usuario"""
        if not new_email or not new_email.strip():
            raise ValueError("Email no puede estar vacío")
        
        self.email = string_utils.normalize_email(new_email)
        self.updated_at = date_utils.get_current_utc()

    def update_password_hash(self, new_password_hash: str):
        """Actualiza el hash de la contraseña"""
        if not new_password_hash:
            raise ValueError("Password hash no puede estar vacío")
        
        self.password_hash = new_password_hash
        self.updated_at = date_utils.get_current_utc()

    def to_public_dict(self) -> dict:
        """Devuelve datos públicos del usuario (sin password_hash)"""
        return {
            "id": self.id,
            "email": self.email,
            "is_active": self.is_active,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }
>>>> app/infrastructure/auth/jwt_handler.py
"""
Manejador de JWT para autenticación.
Genera y valida tokens JWT.
"""
import jwt
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from app.core.config import settings

class JWTHandler:
    """Manejador de tokens JWT."""
    
    @staticmethod
    def create_access_token(user_id: str, email: str) -> str:
        """
        Crea un token JWT de acceso.
        
        Args:
            user_id: ID del usuario
            email: Email del usuario
            
        Returns:
            Token JWT como string
        """
        # Tiempo de expiración
        expire = datetime.utcnow() + timedelta(
            minutes=settings.JWT_EXPIRATION_TIME_MINUTES
        )
        
        # Payload del token
        payload = {
            "user_id": user_id,
            "email": email,
            "exp": expire,
            "iat": datetime.utcnow(),
            "type": "access"
        }
        
        # Generar token
        token = jwt.encode(
            payload,
            settings.JWT_SECRET_KEY,
            algorithm=settings.JWT_ALGORITHM
        )
        
        return token
    
    @staticmethod
    def verify_token(token: str) -> Optional[Dict[str, Any]]:
        """
        Verifica y decodifica un token JWT.
        
        Args:
            token: Token JWT a verificar
            
        Returns:
            Payload del token si es válido, None si es inválido
        """
        try:
            payload = jwt.decode(
                token,
                settings.JWT_SECRET_KEY,
                algorithms=[settings.JWT_ALGORITHM]
            )
            
            # Verificar que sea un token de acceso
            if payload.get("type") != "access":
                return None
                
            return payload
            
        except jwt.ExpiredSignatureError:
            # Token expirado
            return None
        except jwt.InvalidTokenError:
            # Token inválido
            return None
    
    @staticmethod
    def get_user_id_from_token(token: str) -> Optional[str]:
        """
        Extrae el user_id de un token JWT válido.
        
        Args:
            token: Token JWT
            
        Returns:
            user_id si el token es válido, None en caso contrario
        """
        payload = JWTHandler.verify_token(token)
        if payload:
            return payload.get("user_id")
        return None
    
    @staticmethod
    def is_token_expired(token: str) -> bool:
        """
        Verifica si un token ha expirado.
        
        Args:
            token: Token JWT
            
        Returns:
            True si ha expirado, False en caso contrario
        """
        try:
            jwt.decode(
                token,
                settings.JWT_SECRET_KEY,
                algorithms=[settings.JWT_ALGORITHM]
            )
            return False
        except jwt.ExpiredSignatureError:
            return True
        except jwt.InvalidTokenError:
            return True

# Instancia global del JWT handler
jwt_handler = JWTHandler()
>>>> app/infrastructure/auth/password_hashing.py
"""
Servicio de hashing y verificación de contraseñas.
Abstrae la lógica de hash de contraseñas usando bcrypt.
"""
import bcrypt

class PasswordHasher:
    """Manejador de hash y verificación de contraseñas."""
    
    @staticmethod
    def hash_password(password: str) -> str:
        """
        Genera un hash seguro de la contraseña.
        
        Args:
            password: Contraseña en texto plano
            
        Returns:
            Hash de la contraseña como string
        """
        if not password:
            raise ValueError("Password no puede estar vacío")
        
        # Generar salt y hash
        salt = bcrypt.gensalt()
        password_bytes = password.encode('utf-8')
        hash_bytes = bcrypt.hashpw(password_bytes, salt)
        
        return hash_bytes.decode('utf-8')
    
    @staticmethod
    def verify_password(password: str, hashed_password: str) -> bool:
        """
        Verifica si una contraseña coincide con su hash.
        
        Args:
            password: Contraseña en texto plano
            hashed_password: Hash almacenado
            
        Returns:
            True si la contraseña es correcta, False en caso contrario
        """
        if not password or not hashed_password:
            return False
        
        try:
            password_bytes = password.encode('utf-8')
            hashed_bytes = hashed_password.encode('utf-8')
            return bcrypt.checkpw(password_bytes, hashed_bytes)
        except (ValueError, TypeError):
            return False

# Instancia global del hasher
password_hasher = PasswordHasher()
>>>> app/infrastructure/db/mongo_client.py
"""
Cliente Mock de MongoDB para desarrollo.
Simula operaciones de base de datos en memoria hasta implementar MongoDB real.
"""
from typing import Dict, List, Optional, Any
from datetime import datetime
from app.domain.user.user_entity import User

class MockMongoClient:
    """
    Cliente mock que simula operaciones de MongoDB en memoria.
    Será reemplazado por el cliente real de MongoDB posteriormente.
    """
    
    def __init__(self):
        # Almacenamiento en memoria
        self._users_collection: Dict[str, dict] = {}
        self._connected = False
    
    def connect(self) -> bool:
        """Simula conexión a la base de datos."""
        self._connected = True
        return True
    
    def disconnect(self) -> None:
        """Simula desconexión de la base de datos."""
        self._connected = False
    
    def is_connected(self) -> bool:
        """Verifica si está conectado."""
        return self._connected
    
    # Operaciones de usuarios
    def create_user(self, user: User) -> bool:
        """
        Crea un nuevo usuario en la colección.
        
        Args:
            user: Entidad User a crear
            
        Returns:
            True si se creó exitosamente
        """
        if not self._connected:
            raise ConnectionError("Database not connected")
        
        if user.id in self._users_collection:
            return False  # Usuario ya existe
        
        self._users_collection[user.id] = user.to_dict()
        return True
    
    def get_user_by_id(self, user_id: str) -> Optional[User]:
        """
        Obtiene un usuario por su ID.
        
        Args:
            user_id: ID del usuario
            
        Returns:
            Entidad User si existe, None en caso contrario
        """
        if not self._connected:
            raise ConnectionError("Database not connected")
        
        user_data = self._users_collection.get(user_id)
        if user_data:
            return User.from_dict(user_data)
        return None
    
    def get_user_by_email(self, email: str) -> Optional[User]:
        """
        Obtiene un usuario por su email.
        
        Args:
            email: Email del usuario
            
        Returns:
            Entidad User si existe, None en caso contrario
        """
        if not self._connected:
            raise ConnectionError("Database not connected")
        
        email = email.lower().strip()
        for user_data in self._users_collection.values():
            if user_data["email"] == email:
                return User.from_dict(user_data)
        return None
    
    def get_all_users(self, skip: int = 0, limit: int = 100) -> List[User]:
        """
        Obtiene todos los usuarios con paginación.
        
        Args:
            skip: Número de registros a saltar
            limit: Límite de registros a retornar
            
        Returns:
            Lista de entidades User
        """
        if not self._connected:
            raise ConnectionError("Database not connected")
        
        users_data = list(self._users_collection.values())
        paginated_data = users_data[skip:skip + limit]
        
        return [User.from_dict(data) for data in paginated_data]
    
    def update_user(self, user: User) -> bool:
        """
        Actualiza un usuario existente.
        
        Args:
            user: Entidad User con datos actualizados
            
        Returns:
            True si se actualizó exitosamente
        """
        if not self._connected:
            raise ConnectionError("Database not connected")
        
        if user.id not in self._users_collection:
            return False  # Usuario no existe
        
        user.updated_at = datetime.utcnow()
        self._users_collection[user.id] = user.to_dict()
        return True
    
    def delete_user(self, user_id: str) -> bool:
        """
        Elimina un usuario (hard delete).
        
        Args:
            user_id: ID del usuario a eliminar
            
        Returns:
            True si se eliminó exitosamente
        """
        if not self._connected:
            raise ConnectionError("Database not connected")
        
        if user_id not in self._users_collection:
            return False  # Usuario no existe
        
        del self._users_collection[user_id]
        return True
    
    def count_users(self) -> int:
        """
        Cuenta el total de usuarios.
        
        Returns:
            Número total de usuarios
        """
        if not self._connected:
            raise ConnectionError("Database not connected")
        
        return len(self._users_collection)
    
    def clear_all_users(self) -> None:
        """Limpia todos los usuarios (útil para testing)."""
        if not self._connected:
            raise ConnectionError("Database not connected")
        
        self._users_collection.clear()

# Instancia global del cliente mock
mongo_client = MockMongoClient()
>>>> app/infrastructure/db/user_model.py
"""
Modelo de User para la capa de infraestructura.
Abstrae las operaciones de base de datos para la entidad User.
"""
from typing import List, Optional
from app.domain.user.user_entity import User
from app.infrastructure.db.mongo_client import mongo_client

class UserModel:
    """
    Modelo que encapsula las operaciones de base de datos para User.
    Actúa como repositorio para la entidad User.
    """
    
    def __init__(self):
        self.db = mongo_client
    
    async def create(self, user: User) -> User:
        """
        Crea un nuevo usuario en la base de datos.
        
        Args:
            user: Entidad User a crear
            
        Returns:
            Entidad User creada
            
        Raises:
            ValueError: Si el usuario ya existe
        """
        # Verificar si el email ya existe
        existing_user = self.db.get_user_by_email(user.email)
        if existing_user:
            raise ValueError(f"Usuario con email {user.email} ya existe")
        
        # Crear usuario
        success = self.db.create_user(user)
        if not success:
            raise RuntimeError("Error al crear usuario")
        
        return user
    
    async def get_by_id(self, user_id: str) -> Optional[User]:
        """
        Obtiene un usuario por su ID.
        
        Args:
            user_id: ID del usuario
            
        Returns:
            Entidad User si existe, None en caso contrario
        """
        return self.db.get_user_by_id(user_id)
    
    async def get_by_email(self, email: str) -> Optional[User]:
        """
        Obtiene un usuario por su email.
        
        Args:
            email: Email del usuario
            
        Returns:
            Entidad User si existe, None en caso contrario
        """
        return self.db.get_user_by_email(email)
    
    async def get_all(self, skip: int = 0, limit: int = 100) -> List[User]:
        """
        Obtiene todos los usuarios con paginación.
        
        Args:
            skip: Número de registros a saltar
            limit: Límite de registros a retornar
            
        Returns:
            Lista de entidades User
        """
        return self.db.get_all_users(skip=skip, limit=limit)
    
    async def update(self, user: User) -> User:
        """
        Actualiza un usuario existente.
        
        Args:
            user: Entidad User con datos actualizados
            
        Returns:
            Entidad User actualizada
            
        Raises:
            ValueError: Si el usuario no existe
        """
        success = self.db.update_user(user)
        if not success:
            raise ValueError(f"Usuario con ID {user.id} no encontrado")
        
        return user
    
    async def delete(self, user_id: str) -> bool:
        """
        Elimina un usuario por su ID.
        
        Args:
            user_id: ID del usuario a eliminar
            
        Returns:
            True si se eliminó exitosamente
            
        Raises:
            ValueError: Si el usuario no existe
        """
        success = self.db.delete_user(user_id)
        if not success:
            raise ValueError(f"Usuario con ID {user_id} no encontrado")
        
        return True
    
    async def exists_by_email(self, email: str) -> bool:
        """
        Verifica si existe un usuario con el email dado.
        
        Args:
            email: Email a verificar
            
        Returns:
            True si existe, False en caso contrario
        """
        user = self.db.get_user_by_email(email)
        return user is not None
    
    async def count(self) -> int:
        """
        Cuenta el total de usuarios.
        
        Returns:
            Número total de usuarios
        """
        return self.db.count_users()

# Instancia global del modelo
user_model = UserModel()
>>>> app/interfaces/api/v1/api_v1.py
"""
Configuración de la API v1.
Incluye todas las rutas de la versión 1 de la API.
"""
from fastapi import APIRouter
from app.interfaces.api.v1.routes.user_routes import router as user_router
from app.interfaces.api.v1.routes.auth_routes import router as auth_router

# Router principal para la API v1
api_router = APIRouter()

# Incluir rutas de autenticación (sin autenticación requerida)
api_router.include_router(
    auth_router,
    prefix="/auth",
    tags=["authentication"]
)

# Incluir rutas de usuarios (requieren autenticación)
api_router.include_router(
    user_router,
    prefix="/users",
    tags=["users"]
)

# Endpoint de health check
@api_router.get(
    "/health",
    tags=["health"],
    summary="Health Check",
    description="Verifica el estado de la API"
)
async def health_check():
    """
    Endpoint de health check para verificar que la API está funcionando.
    
    Returns información básica del estado del servicio.
    """
    return {
        "status": "healthy",
        "message": "API is running",
        "version": "1.0.0",
        "services": {
            "database": "connected",
            "authentication": "active"
        }
    }

# Endpoint de información de la API
@api_router.get(
    "/info",
    tags=["info"],
    summary="API Information",
    description="Información general sobre la API"
)
async def api_info():
    """
    Proporciona información general sobre la API.
    
    Returns metadatos de la API como versión, descripción, endpoints disponibles, etc.
    """
    return {
        "name": "Clients API",
        "version": "1.0.0",
        "description": "API REST para gestión de usuarios con autenticación JWT",
        "architecture": "Clean Architecture",
        "features": [
            "Registro y autenticación de usuarios",
            "CRUD completo de usuarios",
            "Autenticación JWT",
            "Paginación en listados",
            "Soft delete de usuarios",
            "Validación con Pydantic",
            "Documentación OpenAPI"
        ],
        "endpoints": {
            "authentication": [
                "POST /api/v1/auth/login",
                "POST /api/v1/auth/register"
            ],
            "users": [
                "POST /api/v1/users",
                "GET /api/v1/users/{id}",
                "GET /api/v1/users",
                "PUT /api/v1/users/{id}",
                "DELETE /api/v1/users/{id}"
            ],
            "utility": [
                "GET /api/v1/health",
                "GET /api/v1/info"
            ]
        },
        "authentication": {
            "type": "JWT Bearer Token",
            "header": "Authorization: Bearer <token>",
            "expiration": "30 minutes"
        },
        "documentation": {
            "swagger": "/docs",
            "redoc": "/redoc",
            "openapi": "/api/v1/openapi.json"
        },
        "status": "active"
    }
>>>> app/interfaces/api/v1/routes/auth_routes.py
"""
Rutas de autenticación.
Maneja login, registro y operaciones de autenticación.
"""
from fastapi import APIRouter, Depends, status
from app.controllers.user_controller import user_controller
from app.interfaces.schemas.user_request import (
    UserCreateRequest,
    UserLoginRequest
)
from app.interfaces.schemas.user_response import (
    UserCreateResponse,
    UserLoginResponse,
    ErrorResponse,
    user_to_response
)
from app.core.security import get_current_active_user
from app.core.exceptions import (
    ValidationException,
    AuthenticationException,
    ConflictException,
    InfrastructureException
)

# Router para autenticación
router = APIRouter(tags=["authentication"])

@router.post(
    "/login",
    response_model=UserLoginResponse,
    summary="Iniciar sesión",
    description="Autentica un usuario con email y contraseña, devuelve un token JWT",
    responses={
        200: {"description": "Login exitoso", "model": UserLoginResponse},
        401: {"description": "Credenciales inválidas"},
        400: {"description": "Datos de entrada inválidos"},
        422: {"description": "Usuario inactivo"},
        500: {"description": "Error interno del servidor"}
    }
)
async def login(request: UserLoginRequest):
    """
    Autentica un usuario con email y contraseña.
    
    - **email**: Email del usuario registrado
    - **password**: Contraseña del usuario
    
    Devuelve un token JWT para autenticación en futuras requests.
    
    **Nota**: Las excepciones se manejan automáticamente por el sistema centralizado.
    """
    # Las excepciones específicas del dominio se propagan automáticamente
    # y son manejadas por el sistema centralizado de exception handlers
    result = await user_controller.login_user(request)
    return result

@router.post(
    "/register",
    response_model=UserCreateResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Registrar nuevo usuario",
    description="Crea una nueva cuenta de usuario",
    responses={
        201: {"description": "Usuario creado exitosamente", "model": UserCreateResponse},
        400: {"description": "Datos de entrada inválidos"},
        409: {"description": "Usuario ya existe"},
        500: {"description": "Error interno del servidor"}
    }
)
async def register(request: UserCreateRequest):
    """
    Registra un nuevo usuario.
    
    - **email**: Email válido y único
    - **password**: Contraseña (mínimo 6 caracteres)
    
    Crea el usuario y devuelve la información básica (sin contraseña).
    
    **Nota**: Las excepciones se manejan automáticamente por el sistema centralizado.
    """
    # Las excepciones específicas del dominio se propagan automáticamente
    # y son manejadas por el sistema centralizado de exception handlers
    result = await user_controller.create_user(request)
    return result

@router.get(
    "/validate-token",
    summary="Validar token",
    description="Valida si un token JWT es válido",
    responses={
        200: {"description": "Token válido"},
        401: {"description": "Token inválido o expirado"}
    }
)
async def validate_token(current_user = Depends(get_current_active_user)):
    """
    Valida el token JWT del usuario autenticado.
    
    **Requiere autenticación JWT.**
    
    Endpoint útil para verificar si un token sigue siendo válido.
    """
    user_response = user_to_response(current_user)
    return {
        "valid": True,
        "user": user_response,
        "message": "Token válido"
    }
>>>> app/interfaces/api/v1/routes/user_routes.py
"""
Rutas de la API para operaciones CRUD de usuarios.
Define los endpoints REST para el manejo de usuarios autenticados.
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query
from typing import List
from app.controllers.user_controller import user_controller
from app.interfaces.schemas.user_request import (
    UserCreateRequest,
    UserUpdateRequest,
    UserQueryRequest
)
from app.interfaces.schemas.user_response import (
    UserCreateResponse,
    UserUpdateResponse,
    UserDeleteResponse,
    UserListResponse,
    ErrorResponse,
    user_to_response
)
from app.core.security import get_current_active_user
from app.domain.user.user_entity import User

# Router para las rutas de usuario (requieren autenticación)
router = APIRouter(tags=["users"])

@router.post(
    "",
    response_model=UserCreateResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Crear nuevo usuario",
    description="Crea un nuevo usuario (endpoint administrativo)"
)
async def create_user(
    request: UserCreateRequest,
    current_user: User = Depends(get_current_active_user)
):
    """
    Crea un nuevo usuario.
    
    **Requiere autenticación JWT.**
    
    - **email**: Email válido del usuario
    - **password**: Contraseña (mínimo 6 caracteres)
    
    Este endpoint está protegido y requiere autenticación.
    """
    try:
        return await user_controller.create_user(request)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error interno del servidor"
        )

@router.get(
    "/{user_id}",
    response_model=dict,
    summary="Obtener usuario por ID",
    description="Obtiene información de un usuario específico"
)
async def get_user_by_id(
    user_id: str,
    current_user: User = Depends(get_current_active_user)
):
    """
    Obtiene un usuario por su ID.
    
    **Requiere autenticación JWT.**
    
    - **user_id**: ID único del usuario
    
    Los usuarios solo pueden acceder a su propia información,
    salvo que tengan permisos administrativos.
    """
    try:
        user = await user_controller.get_user_by_id(user_id, current_user)
        user_response = user_to_response(user)
        return {
            "user": user_response,
            "message": "Usuario obtenido exitosamente"
        }
    except ValueError as e:
        error_message = str(e).lower()
        if "no encontrado" in error_message or "not found" in error_message:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=str(e)
            )
        elif "permisos" in error_message or "permission" in error_message:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=str(e)
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(e)
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error interno del servidor"
        )

@router.get(
    "",
    response_model=UserListResponse,
    summary="Listar todos los usuarios",
    description="Obtiene una lista paginada de todos los usuarios"
)
async def list_all_users(
    skip: int = Query(0, ge=0, description="Número de registros a saltar"),
    limit: int = Query(20, ge=1, le=100, description="Límite de registros por página"),
    current_user: User = Depends(get_current_active_user)
):
    """
    Lista todos los usuarios con paginación.
    
    **Requiere autenticación JWT.**
    
    - **skip**: Número de registros a saltar (default: 0)
    - **limit**: Límite de registros por página (default: 20, max: 100)
    
    Devuelve información básica de todos los usuarios activos.
    """
    try:
        query = UserQueryRequest(skip=skip, limit=limit)
        return await user_controller.list_users(query, current_user)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error interno del servidor"
        )

@router.put(
    "/{user_id}",
    response_model=UserUpdateResponse,
    summary="Actualizar usuario",
    description="Actualiza la información de un usuario existente"
)
async def update_user(
    user_id: str,
    request: UserUpdateRequest,
    current_user: User = Depends(get_current_active_user)
):
    """
    Actualiza un usuario existente.
    
    **Requiere autenticación JWT.**
    
    - **user_id**: ID único del usuario a actualizar
    - **email**: Nuevo email (opcional)
    - **password**: Nueva contraseña (opcional)
    
    Los usuarios solo pueden actualizar su propia información,
    salvo que tengan permisos administrativos.
    """
    try:
        return await user_controller.update_user(user_id, request, current_user)
    except ValueError as e:
        error_message = str(e).lower()
        if "no encontrado" in error_message or "not found" in error_message:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=str(e)
            )
        elif "permisos" in error_message or "permission" in error_message:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=str(e)
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(e)
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error interno del servidor"
        )

@router.delete(
    "/{user_id}",
    response_model=UserDeleteResponse,
    summary="Eliminar usuario",
    description="Elimina un usuario del sistema"
)
async def delete_user(
    user_id: str,
    current_user: User = Depends(get_current_active_user)
):
    """
    Elimina un usuario del sistema.
    
    **Requiere autenticación JWT.**
    
    - **user_id**: ID único del usuario a eliminar
    
    Por defecto realiza un soft delete (desactivación).
    Los usuarios solo pueden eliminar su propia cuenta,
    salvo que tengan permisos administrativos.
    """
    try:
        return await user_controller.delete_user_soft(user_id, current_user)
    except ValueError as e:
        error_message = str(e).lower()
        if "no encontrado" in error_message or "not found" in error_message:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=str(e)
            )
        elif "permisos" in error_message or "permission" in error_message:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=str(e)
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(e)
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error interno del servidor"
        )

# Endpoints adicionales para operaciones avanzadas
@router.get(
    "/me/profile",
    response_model=dict,
    summary="Obtener perfil actual",
    description="Obtiene la información del usuario autenticado"
)
async def get_current_user_profile(
    current_user: User = Depends(get_current_active_user)
):
    """
    Obtiene el perfil del usuario autenticado.
    
    **Requiere autenticación JWT.**
    
    Devuelve la información completa del usuario que está autenticado.
    """
    try:
        user_response = user_to_response(current_user)
        return {
            "user": user_response,
            "message": "Perfil obtenido exitosamente"
        }
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error interno del servidor"
        )
>>>> app/interfaces/schemas/user_request.py
"""
Esquemas de request para operaciones de usuario.
Define la estructura de datos de entrada para la API.
"""
from pydantic import BaseModel, EmailStr, validator
from typing import Optional

class UserCreateRequest(BaseModel):
    """Esquema para crear un nuevo usuario."""
    
    email: EmailStr
    password: str
    
    @validator('password')
    def validate_password(cls, v):
        """Valida que la contraseña cumpla con los requisitos mínimos."""
        if len(v) < 6:
            raise ValueError('Password debe tener al menos 6 caracteres')
        if len(v) > 128:
            raise ValueError('Password no puede tener más de 128 caracteres')
        return v
    
    @validator('email')
    def validate_email(cls, v):
        """Valida y normaliza el email."""
        return v.lower().strip()

class UserLoginRequest(BaseModel):
    """Esquema para login de usuario."""
    
    email: EmailStr
    password: str
    
    @validator('email')
    def validate_email(cls, v):
        """Valida y normaliza el email."""
        return v.lower().strip()

class UserUpdateRequest(BaseModel):
    """Esquema para actualizar un usuario."""
    
    email: Optional[EmailStr] = None
    password: Optional[str] = None
    
    @validator('password')
    def validate_password(cls, v):
        """Valida que la contraseña cumpla con los requisitos mínimos."""
        if v is not None:
            if len(v) < 6:
                raise ValueError('Password debe tener al menos 6 caracteres')
            if len(v) > 128:
                raise ValueError('Password no puede tener más de 128 caracteres')
        return v
    
    @validator('email')
    def validate_email(cls, v):
        """Valida y normaliza el email."""
        if v is not None:
            return v.lower().strip()
        return v
    
    def has_updates(self) -> bool:
        """Verifica si hay campos para actualizar."""
        return any([
            self.email is not None,
            self.password is not None
        ])

class UserQueryRequest(BaseModel):
    """Esquema para consultas paginadas de usuarios."""
    
    skip: int = 0
    limit: int = 20
    
    @validator('skip')
    def validate_skip(cls, v):
        """Valida que skip sea no negativo."""
        if v < 0:
            raise ValueError('Skip debe ser mayor o igual a 0')
        return v
    
    @validator('limit')
    def validate_limit(cls, v):
        """Valida que limit esté en un rango razonable."""
        if v < 1:
            raise ValueError('Limit debe ser mayor a 0')
        if v > 100:
            raise ValueError('Limit no puede ser mayor a 100')
        return v
>>>> app/interfaces/schemas/user_response.py
"""
Esquemas de response para operaciones de usuario.
Define la estructura de datos de salida de la API.
"""
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime

class UserResponse(BaseModel):
    """Esquema base de respuesta para usuario."""
    
    id: str
    email: str
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    class Config:
        """Configuración del modelo Pydantic."""
        from_attributes = True
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

class UserCreateResponse(BaseModel):
    """Respuesta para creación de usuario."""
    
    user: UserResponse
    message: str = "Usuario creado exitosamente"

class UserLoginResponse(BaseModel):
    """Respuesta para login de usuario."""
    
    access_token: str
    token_type: str = "bearer"
    user: UserResponse
    expires_in: int  # minutos hasta expiración

class UserUpdateResponse(BaseModel):
    """Respuesta para actualización de usuario."""
    
    user: UserResponse
    message: str = "Usuario actualizado exitosamente"

class UserListResponse(BaseModel):
    """Respuesta para listado de usuarios."""
    
    users: List[UserResponse]
    total: int
    skip: int
    limit: int
    has_more: bool

class UserDeleteResponse(BaseModel):
    """Respuesta para eliminación de usuario."""
    
    message: str = "Usuario eliminado exitosamente"
    deleted_id: str

class ErrorResponse(BaseModel):
    """Respuesta de error estándar."""
    
    error: str
    message: str
    status_code: int

class SuccessResponse(BaseModel):
    """Respuesta de éxito genérica."""
    
    message: str
    success: bool = True

# Funciones de utilidad para convertir entidades a responses
def user_to_response(user) -> UserResponse:
    """Convierte una entidad User a UserResponse."""
    return UserResponse(
        id=user.id,
        email=user.email,
        is_active=user.is_active,
        created_at=user.created_at,
        updated_at=user.updated_at
    )

def users_to_list_response(
    users: List, 
    total: int, 
    skip: int, 
    limit: int
) -> UserListResponse:
    """Convierte una lista de usuarios a UserListResponse."""
    user_responses = [user_to_response(user) for user in users]
    has_more = skip + len(users) < total
    
    return UserListResponse(
        users=user_responses,
        total=total,
        skip=skip,
        limit=limit,
        has_more=has_more
    )
>>>> app/main.py
"""
Punto de entrada principal de la aplicación FastAPI.
Configura la aplicación, middleware, CORS, rutas y manejadores de excepciones.
"""
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from contextlib import asynccontextmanager
import uvicorn
import logging
import time
from datetime import datetime
from app.core.config import settings
from app.interfaces.api.v1.api_v1 import api_router
from app.infrastructure.db.mongo_client import mongo_client
from app.core.exception_handlers import EXCEPTION_HANDLERS

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Maneja el ciclo de vida de la aplicación.
    Se ejecuta al iniciar y al cerrar la aplicación.
    """
    # Startup: Conectar a la base de datos
    logger.info("🚀 Iniciando aplicación...")
    try:
        mongo_client.connect()
        logger.info("✅ Conectado a la base de datos (Mock)")
    except Exception as e:
        logger.error(f"❌ Error al conectar a la base de datos: {e}")
    
    yield
    
    # Shutdown: Cerrar conexiones
    logger.info("🛑 Cerrando aplicación...")
    try:
        mongo_client.disconnect()
        logger.info("✅ Desconectado de la base de datos")
    except Exception as e:
        logger.error(f"❌ Error al desconectar de la base de datos: {e}")

# Crear instancia de FastAPI
app = FastAPI(
    title=settings.PROJECT_NAME,
    version=settings.PROJECT_VERSION,
    description="""
    ## Clients API - Clean Architecture Implementation
    
    API REST para gestión de usuarios con autenticación JWT implementada siguiendo 
    principios de Clean Architecture.
    
    ### 🏗️ Arquitectura
    
    - **Domain Layer**: Entidades y lógica de negocio pura
    - **Application Layer**: Casos de uso y orquestación
    - **Infrastructure Layer**: Implementaciones concretas (BD, Auth, etc.)
    - **Presentation Layer**: Controllers y API endpoints
    
    ### ✨ Características principales
    
    * **🔐 Autenticación JWT**: Sistema seguro de tokens Bearer
    * **👥 CRUD de Usuarios**: Operaciones completas de gestión
    * **📝 Validación robusta**: Validaciones con Pydantic y reglas de negocio
    * **🛡️ Seguridad**: Contraseñas hasheadas con bcrypt
    * **📊 Paginación**: Listados eficientes con paginación
    * **🗑️ Soft Delete**: Desactivación de usuarios sin pérdida de datos
    * **🚨 Manejo de errores**: Sistema centralizado de excepciones
    * **📖 Documentación**: OpenAPI/Swagger completa
    
    ### 🔗 Endpoints principales
    
    #### Autenticación (público)
    - `POST /api/v1/auth/register` - Registrar nuevo usuario
    - `POST /api/v1/auth/login` - Iniciar sesión
    
    #### Usuarios (requiere autenticación)
    - `POST /api/v1/users` - Crear usuario
    - `GET /api/v1/users/{id}` - Obtener usuario por ID
    - `GET /api/v1/users` - Listar usuarios
    - `PUT /api/v1/users/{id}` - Actualizar usuario
    - `DELETE /api/v1/users/{id}` - Eliminar usuario
    
    ### 🔑 Autenticación
    
    Para acceder a endpoints protegidos, incluye el token JWT:
    ```
    Authorization: Bearer <tu_token_jwt>
    ```
    
    ### 🚀 Inicio rápido
    
    1. **Registrarse**: `POST /api/v1/auth/register`
    2. **Iniciar sesión**: `POST /api/v1/auth/login`
    3. **Usar token**: Incluir en header `Authorization: Bearer <token>`
    4. **Explorar API**: Usar los endpoints protegidos
    
    ### 📊 Códigos de respuesta
    
    - `200` - Operación exitosa
    - `201` - Recurso creado
    - `400` - Datos de entrada inválidos
    - `401` - No autenticado
    - `403` - Sin permisos
    - `404` - Recurso no encontrado
    - `409` - Conflicto (ej: email ya existe)
    - `422` - Error de reglas de negocio
    - `500` - Error interno del servidor
    """,
    openapi_url=f"{settings.API_V1_PREFIX}/openapi.json",
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan
)

# Configurar CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["*"],
)

# Registrar manejadores de excepciones
for exception_type, handler in EXCEPTION_HANDLERS.items():
    app.add_exception_handler(exception_type, handler)

# Incluir rutas de la API v1
app.include_router(
    api_router,
    prefix=settings.API_V1_PREFIX
)

# Middleware para logging de requests
import time

@app.middleware("http")
async def log_requests(request: Request, call_next):
    """Middleware para logging de todas las requests."""
    start_time = time.time()
    
    # Log request
    logger.info(f"📥 {request.method} {request.url}")
    
    response = await call_next(request)
    
    # Log response
    process_time = time.time() - start_time
    logger.info(f"📤 {request.method} {request.url} - {response.status_code} - {process_time:.4f}s")
    
    return response

# Endpoint raíz
@app.get(
    "/",
    tags=["root"],
    summary="Root Endpoint",
    description="Endpoint raíz que proporciona información básica de la API"
)
async def root():
    """
    Endpoint raíz con información básica de la API.
    
    Proporciona enlaces útiles y estado general del sistema.
    """
    return {
        "message": f"¡Bienvenido a {settings.PROJECT_NAME}! 🚀",
        "version": settings.PROJECT_VERSION,
        "architecture": "Clean Architecture",
        "status": "active",
        "links": {
            "documentation": "/docs",
            "redoc": "/redoc",
            "api_v1": settings.API_V1_PREFIX,
            "health_check": f"{settings.API_V1_PREFIX}/health",
            "api_info": f"{settings.API_V1_PREFIX}/info"
        },
        "authentication": {
            "register": f"{settings.API_V1_PREFIX}/auth/register",
            "login": f"{settings.API_V1_PREFIX}/auth/login",
            "type": "JWT Bearer Token"
        }
    }

# Endpoint de estado detallado
@app.get(
    "/status",
    tags=["status"],
    summary="Application Status",
    description="Estado detallado de la aplicación y sus componentes"
)
async def status():
    """
    Proporciona información detallada del estado de la aplicación.
    
    Incluye estado de conexiones, configuración y métricas básicas.
    """
    return {
        "application": {
            "name": settings.PROJECT_NAME,
            "version": settings.PROJECT_VERSION,
            "environment": settings.ENVIRONMENT,
            "debug": settings.DEBUG
        },
        "services": {
            "database": {
                "status": "connected" if mongo_client.is_connected() else "disconnected",
                "type": "Mock MongoDB (development)"
            },
            "authentication": {
                "status": "active",
                "type": "JWT",
                "algorithm": settings.JWT_ALGORITHM,
                "expiration_minutes": settings.JWT_EXPIRATION_TIME_MINUTES
            }
        },
        "api": {
            "version": "v1",
            "prefix": settings.API_V1_PREFIX,
            "docs": "/docs",
            "redoc": "/redoc"
        },
        "health_checks": {
            "main": f"{settings.API_V1_PREFIX}/health",
            "detailed": "/status"
        },
        "timestamp": datetime.utcnow().isoformat(),
        "uptime_status": "running"
    }

# Función para ejecutar la aplicación durante desarrollo
def run_dev():
    """
    Ejecuta la aplicación en modo desarrollo.
    Solo usar para desarrollo local.
    """
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )

if __name__ == "__main__":
    run_dev()
>>>> app/use_cases/user/create_user.py
"""
Caso de uso: Crear Usuario.
Encapsula la lógica de negocio para registrar un nuevo usuario.
"""
from app.domain.user.user_entity import User
from app.infrastructure.auth.password_hashing import password_hasher
from app.infrastructure.db.user_model import user_model
from app.core.utils import validation_utils
from app.core.exceptions import (
    ValidationException,
    UserAlreadyExistsException,
    InfrastructureException
)

class CreateUserUseCase:
    """
    Caso de uso para crear un nuevo usuario.
    Maneja toda la lógica de negocio relacionada con el registro.
    """
    
    def __init__(self):
        self.user_model = user_model
        self.password_hasher = password_hasher
        self.validation_utils = validation_utils
    
    async def execute(self, email: str, password: str) -> User:
        """
        Ejecuta el caso de uso de creación de usuario.
        
        Args:
            email: Email del usuario
            password: Contraseña en texto plano
            
        Returns:
            Entidad User creada
            
        Raises:
            ValidationException: Si hay errores de validación de entrada
            UserAlreadyExistsException: Si el usuario ya existe
            InfrastructureException: Si hay errores de infraestructura
        """
        # Validaciones de entrada
        await self._validate_input(email, password)
        
        email = email.lower().strip()
        
        # Verificar si el usuario ya existe
        await self._check_user_not_exists(email)
        
        # Hash de la contraseña
        password_hash = self._hash_password(password)
        
        # Crear nueva entidad User
        new_user = User.create_new_user(
            email=email,
            password_hash=password_hash
        )
        
        # Guardar en la base de datos
        try:
            created_user = await self.user_model.create(new_user)
            return created_user
        except Exception as e:
            raise InfrastructureException(
                f"Error al crear usuario: {str(e)}", 
                "database"
            )
    
    async def _validate_input(self, email: str, password: str):
        """
        Valida los datos de entrada.
        
        Args:
            email: Email a validar
            password: Contraseña a validar
            
        Raises:
            ValidationException: Si hay errores de validación
        """
        if not email or not email.strip():
            raise ValidationException("Email es requerido", "email")
        
        if not password or not password.strip():
            raise ValidationException("Contraseña es requerida", "password")
        
        # Validar formato del email
        if not self.validation_utils.is_valid_email(email):
            raise ValidationException("Formato de email inválido", "email")
        
        # Validar contraseña
        if not self.validation_utils.is_valid_password(password):
            raise ValidationException(
                "La contraseña debe tener entre 6 y 128 caracteres", 
                "password"
            )
    
    async def _check_user_not_exists(self, email: str):
        """
        Verifica que el usuario no exista.
        
        Args:
            email: Email a verificar
            
        Raises:
            UserAlreadyExistsException: Si el usuario ya existe
        """
        existing_user = await self.user_model.get_by_email(email)
        if existing_user:
            raise UserAlreadyExistsException(email)
    
    def _hash_password(self, password: str) -> str:
        """
        Genera el hash de la contraseña.
        
        Args:
            password: Contraseña en texto plano
            
        Returns:
            Hash de la contraseña
            
        Raises:
            InfrastructureException: Si hay error al generar el hash
        """
        try:
            return self.password_hasher.hash_password(password)
        except Exception as e:
            raise InfrastructureException(
                f"Error al procesar contraseña: {str(e)}", 
                "password_hasher"
            )
    
    async def check_email_availability(self, email: str) -> bool:
        """
        Verifica si un email está disponible.
        
        Args:
            email: Email a verificar
            
        Returns:
            True si está disponible, False si ya está en uso
        """
        if not email or not self.validation_utils.is_valid_email(email):
            return False
        
        existing_user = await self.user_model.get_by_email(email.lower().strip())
        return existing_user is None

# Instancia del caso de uso
create_user_use_case = CreateUserUseCase()
>>>> app/use_cases/user/delete_user.py
"""
Caso de uso: Eliminar Usuario.
Encapsula la lógica de negocio para eliminar usuarios.
"""
from app.domain.user.user_entity import User
from app.infrastructure.db.user_model import user_model

class DeleteUserUseCase:
    """
    Caso de uso para eliminar un usuario.
    Maneja tanto soft delete (desactivación) como hard delete (eliminación física).
    """
    
    def __init__(self):
        self.user_model = user_model
    
    async def execute_soft_delete(
        self,
        user_id: str,
        requesting_user_id: str
    ) -> User:
        """
        Ejecuta un soft delete (desactivación) del usuario.
        
        Args:
            user_id: ID del usuario a desactivar
            requesting_user_id: ID del usuario que hace la petición
            
        Returns:
            Entidad User desactivada
            
        Raises:
            ValueError: Si hay errores de validación o permisos
        """
        # Validaciones básicas
        if not user_id or not user_id.strip():
            raise ValueError("User ID es requerido")
        
        if not requesting_user_id or not requesting_user_id.strip():
            raise ValueError("Requesting user ID es requerido")
        
        # Verificar permisos: un usuario solo puede eliminar su propia cuenta
        if user_id != requesting_user_id:
            raise ValueError("No tienes permisos para eliminar este usuario")
        
        # Buscar usuario existente
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        
        if not user.is_active:
            raise ValueError("Usuario ya está inactivo")
        
        # Desactivar usuario (soft delete)
        user.deactivate()
        
        # Guardar cambios
        updated_user = await self.user_model.update(user)
        
        return updated_user
    
    async def execute_hard_delete(
        self,
        user_id: str,
        requesting_user_id: str
    ) -> str:
        """
        Ejecuta un hard delete (eliminación física) del usuario.
        
        Args:
            user_id: ID del usuario a eliminar
            requesting_user_id: ID del usuario que hace la petición
            
        Returns:
            ID del usuario eliminado
            
        Raises:
            ValueError: Si hay errores de validación o permisos
        """
        # Validaciones básicas
        if not user_id or not user_id.strip():
            raise ValueError("User ID es requerido")
        
        if not requesting_user_id or not requesting_user_id.strip():
            raise ValueError("Requesting user ID es requerido")
        
        # Verificar permisos: un usuario solo puede eliminar su propia cuenta
        if user_id != requesting_user_id:
            raise ValueError("No tienes permisos para eliminar este usuario")
        
        # Buscar usuario existente
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        
        # Eliminar usuario físicamente
        await self.user_model.delete(user_id)
        
        return user_id
    
    async def execute_by_admin_soft(self, user_id: str) -> User:
        """
        Ejecuta un soft delete como administrador.
        
        Args:
            user_id: ID del usuario a desactivar
            
        Returns:
            Entidad User desactivada
            
        Raises:
            ValueError: Si el usuario no existe
        """
        if not user_id or not user_id.strip():
            raise ValueError("User ID es requerido")
        
        # Buscar usuario existente
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        
        if not user.is_active:
            raise ValueError("Usuario ya está inactivo")
        
        # Desactivar usuario
        user.deactivate()
        
        # Guardar cambios
        updated_user = await self.user_model.update(user)
        
        return updated_user
    
    async def execute_by_admin_hard(self, user_id: str) -> str:
        """
        Ejecuta un hard delete como administrador.
        
        Args:
            user_id: ID del usuario a eliminar
            
        Returns:
            ID del usuario eliminado
            
        Raises:
            ValueError: Si el usuario no existe
        """
        if not user_id or not user_id.strip():
            raise ValueError("User ID es requerido")
        
        # Buscar usuario existente para validar que existe
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        
        # Eliminar usuario físicamente
        await self.user_model.delete(user_id)
        
        return user_id
    
    async def reactivate_user(
        self,
        user_id: str,
        requesting_user_id: str
    ) -> User:
        """
        Reactiva un usuario desactivado.
        
        Args:
            user_id: ID del usuario a reactivar
            requesting_user_id: ID del usuario que hace la petición
            
        Returns:
            Entidad User reactivada
            
        Raises:
            ValueError: Si hay errores de validación o permisos
        """
        # Validaciones básicas
        if not user_id or not user_id.strip():
            raise ValueError("User ID es requerido")
        
        if not requesting_user_id or not requesting_user_id.strip():
            raise ValueError("Requesting user ID es requerido")
        
        # Verificar permisos
        if user_id != requesting_user_id:
            raise ValueError("No tienes permisos para reactivar este usuario")
        
        # Buscar usuario existente
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        
        if user.is_active:
            raise ValueError("Usuario ya está activo")
        
        # Reactivar usuario
        user.activate()
        
        # Guardar cambios
        updated_user = await self.user_model.update(user)
        
        return updated_user

# Instancia del caso de uso
delete_user_use_case = DeleteUserUseCase()
>>>> app/use_cases/user/get_user_by_id.py
"""
Caso de uso: Obtener Usuario por ID.
Encapsula la lógica de negocio para obtener un usuario específico.
"""
from typing import Optional
from app.domain.user.user_entity import User
from app.infrastructure.db.user_model import user_model

class GetUserByIdUseCase:
    """
    Caso de uso para obtener un usuario por su ID.
    Incluye validaciones de negocio y permisos.
    """
    
    def __init__(self):
        self.user_model = user_model
    
    async def execute(self, user_id: str, requesting_user_id: str) -> User:
        """
        Ejecuta el caso de uso de obtener usuario por ID.
        
        Args:
            user_id: ID del usuario a obtener
            requesting_user_id: ID del usuario que hace la petición
            
        Returns:
            Entidad User encontrada
            
        Raises:
            ValueError: Si hay errores de validación o permisos
        """
        # Validaciones básicas
        if not user_id or not user_id.strip():
            raise ValueError("User ID es requerido")
        
        if not requesting_user_id or not requesting_user_id.strip():
            raise ValueError("Requesting user ID es requerido")
        
        # Buscar usuario
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        
        # Verificar permisos: un usuario solo puede ver su propia información
        # En una implementación más compleja, podríamos tener roles de admin
        if user_id != requesting_user_id:
            raise ValueError("No tienes permisos para ver este usuario")
        
        # Verificar que el usuario esté activo
        if not user.is_active:
            raise ValueError("Usuario no encontrado")
        
        return user
    
    async def execute_by_admin(self, user_id: str) -> User:
        """
        Ejecuta el caso de uso como administrador (sin restricciones de permisos).
        Útil para casos internos del sistema.
        
        Args:
            user_id: ID del usuario a obtener
            
        Returns:
            Entidad User encontrada
            
        Raises:
            ValueError: Si el usuario no existe
        """
        if not user_id or not user_id.strip():
            raise ValueError("User ID es requerido")
        
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        
        return user

# Instancia del caso de uso
get_user_by_id_use_case = GetUserByIdUseCase()
>>>> app/use_cases/user/list_users.py
"""
Caso de uso: Listar Usuarios.
Encapsula la lógica de negocio para obtener una lista paginada de usuarios.
"""
from typing import List, Tuple
from app.domain.user.user_entity import User
from app.infrastructure.db.user_model import user_model

class ListUsersUseCase:
    """
    Caso de uso para listar usuarios con paginación.
    Incluye validaciones y lógica de permisos.
    """
    
    def __init__(self):
        self.user_model = user_model
    
    async def execute(
        self, 
        requesting_user_id: str,
        skip: int = 0, 
        limit: int = 20
    ) -> Tuple[List[User], int]:
        """
        Ejecuta el caso de uso de listar usuarios.
        
        Args:
            requesting_user_id: ID del usuario que hace la petición
            skip: Número de registros a saltar
            limit: Límite de registros a retornar
            
        Returns:
            Tupla con (lista_usuarios, total_usuarios)
            
        Raises:
            ValueError: Si hay errores de validación o permisos
        """
        # Validaciones básicas
        if not requesting_user_id or not requesting_user_id.strip():
            raise ValueError("Requesting user ID es requerido")
        
        if skip < 0:
            raise ValueError("Skip debe ser mayor o igual a 0")
        
        if limit < 1 or limit > 100:
            raise ValueError("Limit debe estar entre 1 y 100")
        
        # Verificar que el usuario solicitante existe y está activo
        requesting_user = await self.user_model.get_by_id(requesting_user_id)
        if not requesting_user or not requesting_user.is_active:
            raise ValueError("Usuario no autorizado")
        
        # Por ahora, cualquier usuario autenticado puede listar usuarios
        # En una implementación más compleja, esto podría estar restringido a admins
        
        # Obtener usuarios
        users = await self.user_model.get_all(skip=skip, limit=limit)
        
        # Filtrar solo usuarios activos (para usuarios normales)
        # En una implementación con roles, los admins podrían ver todos
        active_users = [user for user in users if user.is_active]
        
        # Obtener total de usuarios activos
        total_users = await self._count_active_users()
        
        return active_users, total_users
    
    async def execute_by_admin(
        self, 
        skip: int = 0, 
        limit: int = 20,
        include_inactive: bool = False
    ) -> Tuple[List[User], int]:
        """
        Ejecuta el caso de uso como administrador (sin restricciones).
        
        Args:
            skip: Número de registros a saltar
            limit: Límite de registros a retornar
            include_inactive: Si incluir usuarios inactivos
            
        Returns:
            Tupla con (lista_usuarios, total_usuarios)
        """
        if skip < 0:
            raise ValueError("Skip debe ser mayor o igual a 0")
        
        if limit < 1 or limit > 100:
            raise ValueError("Limit debe estar entre 1 y 100")
        
        # Obtener todos los usuarios
        all_users = await self.user_model.get_all(skip=skip, limit=limit)
        
        if include_inactive:
            users = all_users
            total = await self.user_model.count()
        else:
            users = [user for user in all_users if user.is_active]
            total = await self._count_active_users()
        
        return users, total
    
    async def _count_active_users(self) -> int:
        """
        Cuenta el número de usuarios activos.
        
        Returns:
            Número de usuarios activos
        """
        # En una implementación real con MongoDB, esto sería más eficiente
        # con una query de agregación
        all_users = await self.user_model.get_all(skip=0, limit=1000)  # Límite alto para contar
        active_count = sum(1 for user in all_users if user.is_active)
        return active_count

# Instancia del caso de uso
list_users_use_case = ListUsersUseCase()
>>>> app/use_cases/user/login_user.py
"""
Caso de uso: Login de Usuario.
Encapsula la lógica de negocio para autenticación de usuarios.
"""
from typing import Tuple
from app.domain.user.user_entity import User
from app.infrastructure.auth.password_hashing import password_hasher
from app.infrastructure.auth.jwt_handler import jwt_handler
from app.infrastructure.db.user_model import user_model
from app.core.utils import validation_utils
from app.core.exceptions import (
    ValidationException,
    InvalidCredentialsException,
    UserInactiveException,
    UserNotFoundException
)

class LoginUserUseCase:
    """
    Caso de uso para autenticación de usuario.
    Maneja la validación de credenciales y generación de tokens.
    """
    
    def __init__(self):
        self.user_model = user_model
        self.password_hasher = password_hasher
        self.jwt_handler = jwt_handler
        self.validation_utils = validation_utils
    
    async def execute(self, email: str, password: str) -> Tuple[str, User]:
        """
        Ejecuta el caso de uso de login de usuario.
        
        Args:
            email: Email del usuario
            password: Contraseña en texto plano
            
        Returns:
            Tupla con (token_jwt, entidad_user)
            
        Raises:
            ValidationException: Si los datos de entrada son inválidos
            InvalidCredentialsException: Si las credenciales son incorrectas
            UserInactiveException: Si el usuario está inactivo
        """
        # Validaciones de entrada
        if not email or not email.strip():
            raise ValidationException("Email es requerido", "email")
        
        if not password or not password.strip():
            raise ValidationException("Contraseña es requerida", "password")
        
        # Validar formato del email
        if not self.validation_utils.is_valid_email(email):
            raise ValidationException("Formato de email inválido", "email")
        
        email = email.lower().strip()
        
        # Buscar usuario por email
        user = await self.user_model.get_by_email(email)
        if not user:
            # Por seguridad, no revelamos si el email existe o no
            raise InvalidCredentialsException()
        
        # Verificar si el usuario está activo
        if not user.is_active:
            raise UserInactiveException(user.id)
        
        # Verificar contraseña
        is_valid_password = self.password_hasher.verify_password(
            password, user.password_hash
        )
        if not is_valid_password:
            raise InvalidCredentialsException()
        
        # Generar token JWT
        access_token = self.jwt_handler.create_access_token(
            user_id=user.id,
            email=user.email
        )
        
        return access_token, user
    
    async def validate_credentials(self, email: str, password: str) -> bool:
        """
        Valida credenciales sin generar token.
        Útil para validaciones internas.
        
        Args:
            email: Email del usuario
            password: Contraseña en texto plano
            
        Returns:
            True si las credenciales son válidas, False en caso contrario
        """
        try:
            await self.execute(email, password)
            return True
        except (InvalidCredentialsException, UserInactiveException, ValidationException):
            return False

# Instancia del caso de uso
login_user_use_case = LoginUserUseCase()
>>>> app/use_cases/user/update_user.py
"""
Caso de uso: Actualizar Usuario.
Encapsula la lógica de negocio para actualizar información de usuario.
"""
from typing import Optional
from app.domain.user.user_entity import User
from app.infrastructure.auth.password_hashing import password_hasher
from app.infrastructure.db.user_model import user_model
from app.core.utils import validation_utils

class UpdateUserUseCase:
    """
    Caso de uso para actualizar un usuario existente.
    Maneja validaciones, permisos y lógica de negocio.
    """
    
    def __init__(self):
        self.user_model = user_model
        self.password_hasher = password_hasher
        self.validation_utils = validation_utils
    
    async def execute(
        self,
        user_id: str,
        requesting_user_id: str,
        new_email: Optional[str] = None,
        new_password: Optional[str] = None
    ) -> User:
        """
        Ejecuta el caso de uso de actualización de usuario.
        
        Args:
            user_id: ID del usuario a actualizar
            requesting_user_id: ID del usuario que hace la petición
            new_email: Nuevo email (opcional)
            new_password: Nueva contraseña (opcional)
            
        Returns:
            Entidad User actualizada
            
        Raises:
            ValueError: Si hay errores de validación o permisos
        """
        # Validaciones básicas
        if not user_id or not user_id.strip():
            raise ValueError("User ID es requerido")
        
        if not requesting_user_id or not requesting_user_id.strip():
            raise ValueError("Requesting user ID es requerido")
        
        # Verificar que hay algo que actualizar
        if not new_email and not new_password:
            raise ValueError("Debe proporcionar al menos un campo para actualizar")
        
        # Verificar permisos: un usuario solo puede actualizar su propia información
        if user_id != requesting_user_id:
            raise ValueError("No tienes permisos para actualizar este usuario")
        
        # Buscar usuario existente
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        
        if not user.is_active:
            raise ValueError("Usuario inactivo")
        
        # Validar y actualizar email si se proporciona
        if new_email:
            await self._update_user_email(user, new_email)
        
        # Validar y actualizar contraseña si se proporciona
        if new_password:
            await self._update_user_password(user, new_password)
        
        # Guardar cambios
        updated_user = await self.user_model.update(user)
        
        return updated_user
    
    async def _update_user_email(self, user: User, new_email: str):
        """
        Actualiza el email del usuario con validaciones.
        
        Args:
            user: Entidad User a actualizar
            new_email: Nuevo email
            
        Raises:
            ValueError: Si el email es inválido o ya está en uso
        """
        # Validar formato del email
        if not self.validation_utils.is_valid_email(new_email):
            raise ValueError("El formato del email es inválido")
        
        new_email = new_email.lower().strip()
        
        # Verificar que el email no esté en uso por otro usuario
        existing_user = await self.user_model.get_by_email(new_email)
        if existing_user and existing_user.id != user.id:
            raise ValueError(f"El email {new_email} ya está en uso por otro usuario")
        
        # Actualizar email en la entidad
        user.update_email(new_email)
    
    async def _update_user_password(self, user: User, new_password: str):
        """
        Actualiza la contraseña del usuario con validaciones.
        
        Args:
            user: Entidad User a actualizar
            new_password: Nueva contraseña
            
        Raises:
            ValueError: Si la contraseña no cumple los requisitos
        """
        # Validar contraseña
        if not self.validation_utils.is_valid_password(new_password):
            raise ValueError("La contraseña debe tener entre 6 y 128 caracteres")
        
        # Generar nuevo hash
        new_password_hash = self.password_hasher.hash_password(new_password)
        
        # Actualizar contraseña en la entidad
        user.update_password_hash(new_password_hash)
    
    async def execute_by_admin(
        self,
        user_id: str,
        new_email: Optional[str] = None,
        new_password: Optional[str] = None,
        is_active: Optional[bool] = None
    ) -> User:
        """
        Ejecuta el caso de uso como administrador (sin restricciones de permisos).
        
        Args:
            user_id: ID del usuario a actualizar
            new_email: Nuevo email (opcional)
            new_password: Nueva contraseña (opcional)
            is_active: Nuevo estado activo (opcional)
            
        Returns:
            Entidad User actualizada
            
        Raises:
            ValueError: Si hay errores de validación
        """
        if not user_id or not user_id.strip():
            raise ValueError("User ID es requerido")
        
        # Verificar que hay algo que actualizar
        if not new_email and not new_password and is_active is None:
            raise ValueError("Debe proporcionar al menos un campo para actualizar")
        
        # Buscar usuario existente
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        
        # Actualizar email si se proporciona
        if new_email:
            await self._update_user_email(user, new_email)
        
        # Actualizar contraseña si se proporciona
        if new_password:
            await self._update_user_password(user, new_password)
        
        # Actualizar estado activo si se proporciona
        if is_active is not None:
            if is_active:
                user.activate()
            else:
                user.deactivate()
        
        # Guardar cambios
        updated_user = await self.user_model.update(user)
        
        return updated_user

# Instancia del caso de uso
update_user_use_case = UpdateUserUseCase()
>>>> docker-compose.yml

>>>> docker/mongo-init.js

>>>> requirements.txt
# FastAPI y servidor
fastapi==0.103.2
uvicorn[standard]==0.23.2

# Validación y serialización
pydantic==1.10.13  # Última versión estable de Pydantic v1 compatible con más herramientas

# Autenticación y seguridad
PyJWT==2.8.0
python-jose[cryptography]==3.3.0
bcrypt==4.1.2
passlib[bcrypt]==1.7.4

# Utilidades
python-multipart==0.0.6
email-validator==1.3.1  # Versión estable y no yankeada

# Desarrollo y testing
pytest==7.4.3
pytest-asyncio==0.21.1
httpx==0.25.2

>>>> tests/integration/test_user_endpoints.py

>>>> tests/unit/test_entities.py

>>>> tests/unit/test_use_cases.py
