>>>> Dockerfile

>>>> README.md
# Clients API - Documentaci√≥n

## Informaci√≥n General

Esta API REST implementa un sistema completo de gesti√≥n de usuarios con autenticaci√≥n JWT siguiendo los principios de Clean Architecture.

### Base URL
```
http://localhost:8000
```

### Versi√≥n de API
```
/api/v1
```

## Autenticaci√≥n

La API utiliza autenticaci√≥n JWT (JSON Web Tokens). Despu√©s del login exitoso, incluye el token en el header de todas las requests protegidas:

```http
Authorization: Bearer <tu_token_jwt>
```

### Flujo de Autenticaci√≥n

1. **Registrarse**: `POST /api/v1/auth/register`
2. **Iniciar sesi√≥n**: `POST /api/v1/auth/login`
3. **Usar token**: Incluir en header `Authorization: Bearer <token>`

## Endpoints

### üîê Autenticaci√≥n (P√∫blico)

#### Registrar Usuario
```http
POST /api/v1/auth/register
Content-Type: application/json

{
  "email": "usuario@ejemplo.com",
  "password": "mi_password_seguro"
}
```

**Respuesta exitosa (201):**
```json
{
  "user": {
    "id": "uuid-generado",
    "email": "usuario@ejemplo.com",
    "is_active": true,
    "created_at": "2023-12-01T10:00:00Z",
    "updated_at": "2023-12-01T10:00:00Z"
  },
  "message": "Usuario creado exitosamente"
}
```

#### Iniciar Sesi√≥n
```http
POST /api/v1/auth/login
Content-Type: application/json

{
  "email": "usuario@ejemplo.com",
  "password": "mi_password_seguro"
}
```

**Respuesta exitosa (200):**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer",
  "expires_in": 30,
  "user_id": "uuid-del-usuario",
  "email": "usuario@ejemplo.com",
  "user": {
    "id": "uuid-del-usuario",
    "email": "usuario@ejemplo.com",
    "is_active": true,
    "created_at": "2023-12-01T10:00:00Z",
    "updated_at": "2023-12-01T10:00:00Z"
  }
}
```

#### Validar Token
```http
GET /api/v1/auth/validate-token
Authorization: Bearer <token>
```

**Respuesta exitosa (200):**
```json
{
  "valid": true,
  "user": {
    "id": "uuid-del-usuario",
    "email": "usuario@ejemplo.com",
    "is_active": true,
    "created_at": "2023-12-01T10:00:00Z",
    "updated_at": "2023-12-01T10:00:00Z"
  },
  "message": "Token v√°lido"
}
```

### üë• Usuarios (Requiere Autenticaci√≥n)

#### Crear Usuario
```http
POST /api/v1/users
Authorization: Bearer <token>
Content-Type: application/json

{
  "email": "nuevo@ejemplo.com",
  "password": "password123"
}
```

#### Obtener Usuario por ID
```http
GET /api/v1/users/{user_id}
Authorization: Bearer <token>
```

**Respuesta exitosa (200):**
```json
{
  "user": {
    "id": "uuid-del-usuario",
    "email": "usuario@ejemplo.com",
    "is_active": true,
    "created_at": "2023-12-01T10:00:00Z",
    "updated_at": "2023-12-01T10:00:00Z"
  },
  "message": "Usuario obtenido exitosamente"
}
```

#### Listar Usuarios
```http
GET /api/v1/users?skip=0&limit=20
Authorization: Bearer <token>
```

**Par√°metros de consulta:**
- `skip` (opcional): N√∫mero de registros a saltar (default: 0)
- `limit` (opcional): L√≠mite de registros por p√°gina (default: 20, max: 100)

**Respuesta exitosa (200):**
```json
{
  "users": [
    {
      "id": "uuid1",
      "email": "user1@ejemplo.com",
      "is_active": true,
      "created_at": "2023-12-01T10:00:00Z",
      "updated_at": "2023-12-01T10:00:00Z"
    },
    {
      "id": "uuid2",
      "email": "user2@ejemplo.com",
      "is_active": true,
      "created_at": "2023-12-01T10:30:00Z",
      "updated_at": "2023-12-01T10:30:00Z"
    }
  ],
  "total": 150,
  "skip": 0,
  "limit": 20,
  "has_more": true
}
```

#### Actualizar Usuario
```http
PUT /api/v1/users/{user_id}
Authorization: Bearer <token>
Content-Type: application/json

{
  "email": "nuevo_email@ejemplo.com",
  "password": "nueva_password"
}
```

**Nota**: Ambos campos son opcionales, pero al menos uno debe estar presente.

#### Eliminar Usuario (Soft Delete)
```http
DELETE /api/v1/users/{user_id}
Authorization: Bearer <token>
```

**Respuesta exitosa (200):**
```json
{
  "message": "Usuario desactivado exitosamente",
  "deleted_id": "uuid-del-usuario"
}
```

#### Obtener Perfil Actual
```http
GET /api/v1/users/me/profile
Authorization: Bearer <token>
```

### üîß Utilidad

#### Health Check
```http
GET /api/v1/health
```

**Respuesta exitosa (200):**
```json
{
  "status": "healthy",
  "message": "API is running",
  "version": "1.0.0",
  "services": {
    "database": "connected",
    "authentication": "active"
  }
}
```

#### Informaci√≥n de la API
```http
GET /api/v1/info
```

#### Estado de la Aplicaci√≥n
```http
GET /status
```

## C√≥digos de Respuesta

### C√≥digos de √âxito
- **200 OK**: Operaci√≥n exitosa
- **201 Created**: Recurso creado exitosamente

### C√≥digos de Error
- **400 Bad Request**: Datos de entrada inv√°lidos
- **401 Unauthorized**: No autenticado o token inv√°lido
- **403 Forbidden**: Sin permisos para la operaci√≥n
- **404 Not Found**: Recurso no encontrado
- **409 Conflict**: Conflicto de recursos (ej: email ya existe)
- **422 Unprocessable Entity**: Error de reglas de negocio
- **500 Internal Server Error**: Error interno del servidor

## Formato de Errores

Todos los errores siguen un formato est√°ndar:

```json
{
  "error": true,
  "message": "Descripci√≥n del error",
  "status_code": 400,
  "error_code": "VALIDATION_ERROR",
  "timestamp": "2023-12-01T10:00:00Z",
  "path": "/api/v1/users",
  "details": {
    "field": "email",
    "additional_info": "..."
  }
}
```

## Validaciones

### Email
- Debe tener formato v√°lido
- Se normaliza a min√∫sculas autom√°ticamente
- Debe ser √∫nico en el sistema

### Contrase√±a
- M√≠nimo 6 caracteres
- M√°ximo 128 caracteres
- Se almacena hasheada con bcrypt

### Paginaci√≥n
- `skip`: ‚â• 0
- `limit`: 1-100

## Permisos

### Reglas Generales
- Los usuarios solo pueden ver/modificar su propia informaci√≥n
- Todas las operaciones CRUD requieren autenticaci√≥n
- Los endpoints p√∫blicos son solo `/auth/register` y `/auth/login`

### Casos Especiales
- Un usuario puede ver la lista de otros usuarios (solo informaci√≥n b√°sica)
- Un usuario solo puede eliminar su propia cuenta
- Un usuario solo puede actualizar su propia informaci√≥n

## Ejemplos de Uso

### Flujo Completo de Registro y Uso

```bash
# 1. Registrar nuevo usuario
curl -X POST http://localhost:8000/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@ejemplo.com",
    "password": "password123"
  }'

# 2. Iniciar sesi√≥n
curl -X POST http://localhost:8000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@ejemplo.com",
    "password": "password123"
  }'

# 3. Usar el token obtenido para acceder a endpoints protegidos
TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

# 4. Obtener perfil
curl -X GET http://localhost:8000/api/v1/users/me/profile \
  -H "Authorization: Bearer $TOKEN"

# 5. Listar usuarios
curl -X GET "http://localhost:8000/api/v1/users?skip=0&limit=10" \
  -H "Authorization: Bearer $TOKEN"

# 6. Actualizar perfil
curl -X PUT http://localhost:8000/api/v1/users/{user_id} \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "nuevo_email@ejemplo.com"
  }'
```

## Documentaci√≥n Interactiva

Una vez que la API est√© ejecut√°ndose, puedes acceder a:

- **Swagger UI**: http://localhost:8000/docs
- **ReDoc**: http://localhost:8000/redoc
- **OpenAPI JSON**: http://localhost:8000/api/v1/openapi.json

## Arquitectura

La API sigue principios de Clean Architecture con las siguientes capas:

- **Domain**: Entidades y l√≥gica de negocio pura
- **Application**: Casos de uso y orquestaci√≥n
- **Infrastructure**: Implementaciones concretas (BD, Auth, etc.)
- **Presentation**: Controllers y endpoints de API

## Tecnolog√≠as

- **FastAPI**: Framework web
- **Pydantic**: Validaci√≥n y serializaci√≥n
- **JWT**: Autenticaci√≥n
- **bcrypt**: Hash de contrase√±as
- **Uvicorn**: Servidor ASGI


>>>> app/controllers/user_controller.py
from app.use_cases.user.create_user import create_user_use_case
from app.use_cases.user.login_user import login_user_use_case
from app.use_cases.user.get_user_by_id import get_user_by_id_use_case
from app.use_cases.user.list_users import list_users_use_case
from app.use_cases.user.update_user import update_user_use_case
from app.use_cases.user.delete_user import delete_user_use_case
from app.interfaces.schemas.user_request import (
    UserCreateRequest,
    UserLoginRequest,
    UserUpdateRequest,
    UserQueryRequest
)

class UserController:
    def __init__(self):
        self.create_user_use_case = create_user_use_case
        self.login_user_use_case = login_user_use_case
        self.get_user_by_id_use_case = get_user_by_id_use_case
        self.list_users_use_case = list_users_use_case
        self.update_user_use_case = update_user_use_case
        self.delete_user_use_case = delete_user_use_case

    async def create_user(self, request: UserCreateRequest):
        """
        Crea un nuevo usuario.
        
        Args:
            request: Datos del usuario a crear
            
        Returns:
            Diccionario con informaci√≥n del usuario creado
        """
        user = await self.create_user_use_case.execute(request.email, request.password)
        return {"user": user, "message": "Usuario creado exitosamente"}

    async def login_user(self, request: UserLoginRequest):
        """
        Autentica un usuario y genera token JWT.
        
        Args:
            request: Credenciales de login
            
        Returns:
            Diccionario con token y datos del usuario
        """
        token, user = await self.login_user_use_case.execute(request.email, request.password)
        from app.core.security import create_token_response_data
        return create_token_response_data(token, user) | {"user": user}

    async def get_user_by_id(self, user_id: str, current_user):
        """
        Obtiene un usuario por su ID.
        
        Args:
            user_id: ID del usuario a obtener
            current_user: Usuario autenticado que hace la petici√≥n
            
        Returns:
            Entidad User encontrada
        """
        return await self.get_user_by_id_use_case.execute(user_id, current_user.id)

    async def get_current_user_profile(self, current_user):
        """
        Obtiene el perfil del usuario autenticado.
        
        Args:
            current_user: Usuario autenticado
            
        Returns:
            Entidad User del usuario autenticado
        """
        return await self.get_user_by_id_use_case.execute_own_profile(current_user.id)

    async def list_users(self, query: UserQueryRequest, current_user):
        """
        Lista usuarios con paginaci√≥n.
        
        Args:
            query: Par√°metros de consulta (skip, limit)
            current_user: Usuario autenticado que hace la petici√≥n
            
        Returns:
            Diccionario con lista de usuarios y metadatos de paginaci√≥n
        """
        users, total = await self.list_users_use_case.execute(
            requesting_user_id=current_user.id,
            skip=query.skip,
            limit=query.limit
        )
        from app.interfaces.schemas.user_response import users_to_list_response
        return users_to_list_response(users, total, query.skip, query.limit)

    async def update_user(self, user_id: str, request: UserUpdateRequest, current_user):
        """
        Actualiza un usuario existente.
        
        Args:
            user_id: ID del usuario a actualizar
            request: Datos de actualizaci√≥n
            current_user: Usuario autenticado que hace la petici√≥n
            
        Returns:
            Diccionario con informaci√≥n del usuario actualizado
        """
        user = await self.update_user_use_case.execute(
            user_id=user_id,
            requesting_user_id=current_user.id,
            new_email=request.email,
            new_password=request.password
        )
        return {"user": user, "message": "Usuario actualizado exitosamente"}

    async def delete_user_soft(self, user_id: str, current_user):
        """
        Elimina un usuario (soft delete).
        
        Args:
            user_id: ID del usuario a eliminar
            current_user: Usuario autenticado que hace la petici√≥n
            
        Returns:
            Diccionario con confirmaci√≥n de eliminaci√≥n
        """
        user = await self.delete_user_use_case.execute_soft_delete(user_id, current_user.id)
        return {"message": "Usuario desactivado exitosamente", "deleted_id": user.id}

    async def delete_user_hard(self, user_id: str, current_user):
        """
        Elimina un usuario permanentemente (hard delete).
        
        Args:
            user_id: ID del usuario a eliminar
            current_user: Usuario autenticado que hace la petici√≥n
            
        Returns:
            Diccionario con confirmaci√≥n de eliminaci√≥n
        """
        deleted_id = await self.delete_user_use_case.execute_hard_delete(user_id, current_user.id)
        return {"message": "Usuario eliminado permanentemente", "deleted_id": deleted_id}

    async def reactivate_user(self, user_id: str, current_user):
        """
        Reactiva un usuario desactivado.
        
        Args:
            user_id: ID del usuario a reactivar
            current_user: Usuario autenticado que hace la petici√≥n
            
        Returns:
            Diccionario con informaci√≥n del usuario reactivado
        """
        user = await self.delete_user_use_case.reactivate_user(user_id, current_user.id)
        return {"user": user, "message": "Usuario reactivado exitosamente"}

# Instancia global
user_controller = UserController()
>>>> app/core/config.py
"""
Configuraci√≥n central de la aplicaci√≥n.
Maneja variables de entorno y configuraciones generales.
"""
from typing import Optional
import os

class Settings:
    """Configuraciones de la aplicaci√≥n."""
    
    # JWT Configuration
    JWT_SECRET_KEY: str = os.getenv("JWT_SECRET_KEY", "your-secret-key-change-in-production")
    JWT_ALGORITHM: str = "HS256"
    JWT_EXPIRATION_TIME_MINUTES: int = int(os.getenv("JWT_EXPIRATION_TIME_MINUTES", "30"))
    
    # API Configuration
    API_V1_PREFIX: str = "/api/v1"
    PROJECT_NAME: str = "Clients API"
    PROJECT_VERSION: str = "1.0.0"
    
    # CORS Configuration
    ALLOWED_ORIGINS: list = ["*"]  # En producci√≥n, especificar dominios exactos
    
    # MongoDB Configuration
    MONGODB_URL: str = os.getenv("MONGODB_URL", "mongodb://localhost:27017")
    DATABASE_NAME: str = os.getenv("DATABASE_NAME", "clients_db")
    USERS_COLLECTION: str = os.getenv("USERS_COLLECTION", "users")
    
    # Environment
    ENVIRONMENT: str = os.getenv("ENVIRONMENT", "development")
    DEBUG: bool = ENVIRONMENT == "development"

# Instancia global de configuraci√≥n
settings = Settings()
>>>> app/core/exception_handlers.py
"""
Manejadores de excepciones centralizados.
Convierte excepciones del dominio en respuestas HTTP apropiadas.
"""
from fastapi import Request, HTTPException, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from pydantic import ValidationError
import logging
from datetime import datetime
from app.core.exceptions import (
    DomainException,
    ValidationException,
    AuthenticationException,
    AuthorizationException,
    NotFoundException,
    ConflictException,
    BusinessRuleException,
    InfrastructureException,
    UserAlreadyExistsException,
    UserNotFoundException,
    UserInactiveException,
    InvalidCredentialsException,
    TokenExpiredException,
    InvalidTokenException
)

# Configurar logger
logger = logging.getLogger(__name__)

class ExceptionHandler:
    """Manejador centralizado de excepciones."""
    
    @staticmethod
    def create_error_response(
        status_code: int,
        message: str,
        error_code: str = None,
        details: dict = None,
        path: str = None
    ) -> JSONResponse:
        """
        Crea una respuesta de error est√°ndar.
        
        Args:
            status_code: C√≥digo de estado HTTP
            message: Mensaje de error
            error_code: C√≥digo de error interno
            details: Detalles adicionales del error
            path: Ruta donde ocurri√≥ el error
            
        Returns:
            JSONResponse con formato est√°ndar de error
        """
        error_data = {
            "error": True,
            "message": message,
            "status_code": status_code,
            "timestamp": datetime.utcnow().isoformat(),
        }
        
        if error_code:
            error_data["error_code"] = error_code
        
        if details:
            error_data["details"] = details
        
        if path:
            error_data["path"] = path
        
        return JSONResponse(
            status_code=status_code,
            content=error_data
        )

# Manejadores espec√≠ficos para cada tipo de excepci√≥n
async def domain_exception_handler(request: Request, exc: DomainException):
    """Manejador para excepciones generales del dominio."""
    logger.warning(f"Domain exception: {exc.message}")
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_400_BAD_REQUEST,
        message=exc.message,
        error_code=exc.error_code,
        path=str(request.url)
    )

async def validation_exception_handler(request: Request, exc: ValidationException):
    """Manejador para errores de validaci√≥n."""
    logger.info(f"Validation error: {exc.message}")
    
    details = {}
    if exc.field:
        details["field"] = exc.field
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_400_BAD_REQUEST,
        message=exc.message,
        error_code=exc.error_code,
        details=details if details else None,
        path=str(request.url)
    )

async def authentication_exception_handler(request: Request, exc: AuthenticationException):
    """Manejador para errores de autenticaci√≥n."""
    logger.info(f"Authentication error: {exc.message}")
    
    headers = {"WWW-Authenticate": "Bearer"}
    
    response = ExceptionHandler.create_error_response(
        status_code=status.HTTP_401_UNAUTHORIZED,
        message=exc.message,
        error_code=exc.error_code,
        path=str(request.url)
    )
    
    response.headers.update(headers)
    return response

async def authorization_exception_handler(request: Request, exc: AuthorizationException):
    """Manejador para errores de autorizaci√≥n."""
    logger.warning(f"Authorization error: {exc.message}")
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_403_FORBIDDEN,
        message=exc.message,
        error_code=exc.error_code,
        path=str(request.url)
    )

async def not_found_exception_handler(request: Request, exc: NotFoundException):
    """Manejador para recursos no encontrados."""
    logger.info(f"Resource not found: {exc.message}")
    
    details = {}
    if exc.resource:
        details["resource"] = exc.resource
    if exc.identifier:
        details["identifier"] = exc.identifier
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_404_NOT_FOUND,
        message=exc.message,
        error_code=exc.error_code,
        details=details if details else None,
        path=str(request.url)
    )

async def conflict_exception_handler(request: Request, exc: ConflictException):
    """Manejador para conflictos de recursos."""
    logger.info(f"Resource conflict: {exc.message}")
    
    details = {}
    if exc.resource:
        details["resource"] = exc.resource
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_409_CONFLICT,
        message=exc.message,
        error_code=exc.error_code,
        details=details if details else None,
        path=str(request.url)
    )

async def business_rule_exception_handler(request: Request, exc: BusinessRuleException):
    """Manejador para violaciones de reglas de negocio."""
    logger.warning(f"Business rule violation: {exc.message}")
    
    details = {}
    if exc.rule:
        details["rule"] = exc.rule
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        message=exc.message,
        error_code=exc.error_code,
        details=details if details else None,
        path=str(request.url)
    )

async def infrastructure_exception_handler(request: Request, exc: InfrastructureException):
    """Manejador para errores de infraestructura."""
    logger.error(f"Infrastructure error: {exc.message}")
    
    details = {}
    if exc.component:
        details["component"] = exc.component
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        message="Error interno del sistema",  # No exponer detalles internos
        error_code=exc.error_code,
        details=details if details else None,
        path=str(request.url)
    )

# Manejadores para excepciones est√°ndar de FastAPI
async def http_exception_handler(request: Request, exc: HTTPException):
    """Manejador para excepciones HTTP de FastAPI."""
    logger.info(f"HTTP exception: {exc.detail}")
    
    return ExceptionHandler.create_error_response(
        status_code=exc.status_code,
        message=exc.detail,
        path=str(request.url)
    )

async def request_validation_exception_handler(request: Request, exc: RequestValidationError):
    """Manejador para errores de validaci√≥n de requests."""
    logger.info(f"Request validation error: {exc.errors()}")
    
    # Formatear errores de validaci√≥n de Pydantic
    errors = []
    for error in exc.errors():
        field = " -> ".join(str(loc) for loc in error["loc"])
        errors.append({
            "field": field,
            "message": error["msg"],
            "type": error["type"]
        })
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        message="Datos de entrada inv√°lidos",
        error_code="VALIDATION_ERROR",
        details={"validation_errors": errors},
        path=str(request.url)
    )

async def general_exception_handler(request: Request, exc: Exception):
    """Manejador para excepciones generales no capturadas."""
    logger.error(f"Unhandled exception: {str(exc)}", exc_info=True)
    
    return ExceptionHandler.create_error_response(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        message="Error interno del servidor",
        error_code="INTERNAL_ERROR",
        path=str(request.url)
    )

# Diccionario con todos los manejadores
EXCEPTION_HANDLERS = {
    # Excepciones del dominio
    ValidationException: validation_exception_handler,
    AuthenticationException: authentication_exception_handler,
    AuthorizationException: authorization_exception_handler,
    NotFoundException: not_found_exception_handler,
    ConflictException: conflict_exception_handler,
    BusinessRuleException: business_rule_exception_handler,
    InfrastructureException: infrastructure_exception_handler,
    DomainException: domain_exception_handler,
    
    # Excepciones espec√≠ficas de usuarios
    UserAlreadyExistsException: conflict_exception_handler,
    UserNotFoundException: not_found_exception_handler,
    UserInactiveException: business_rule_exception_handler,
    InvalidCredentialsException: authentication_exception_handler,
    TokenExpiredException: authentication_exception_handler,
    InvalidTokenException: authentication_exception_handler,
    
    # Excepciones est√°ndar de FastAPI
    HTTPException: http_exception_handler,
    RequestValidationError: request_validation_exception_handler,
    
    # Excepci√≥n general
    Exception: general_exception_handler,
}
>>>> app/core/exceptions.py
"""
Excepciones personalizadas para la aplicaci√≥n.
Define excepciones espec√≠ficas del dominio para mejor manejo de errores.
"""

class DomainException(Exception):
    """Excepci√≥n base para errores del dominio."""
    
    def __init__(self, message: str, error_code: str = None):
        super().__init__(message)
        self.message = message
        self.error_code = error_code


class ValidationException(DomainException):
    """Excepci√≥n para errores de validaci√≥n."""
    
    def __init__(self, message: str, field: str = None):
        super().__init__(message, "VALIDATION_ERROR")
        self.field = field


class AuthenticationException(DomainException):
    """Excepci√≥n para errores de autenticaci√≥n."""
    
    def __init__(self, message: str = "Credenciales inv√°lidas"):
        super().__init__(message, "AUTHENTICATION_ERROR")


class AuthorizationException(DomainException):
    """Excepci√≥n para errores de autorizaci√≥n."""
    
    def __init__(self, message: str = "No tienes permisos para esta operaci√≥n"):
        super().__init__(message, "AUTHORIZATION_ERROR")


class NotFoundException(DomainException):
    """Excepci√≥n para recursos no encontrados."""
    
    def __init__(self, resource: str, identifier: str = None):
        if identifier:
            message = f"{resource} con ID '{identifier}' no encontrado"
        else:
            message = f"{resource} no encontrado"
        super().__init__(message, "NOT_FOUND")
        self.resource = resource
        self.identifier = identifier


class ConflictException(DomainException):
    """Excepci√≥n para conflictos de recursos."""
    
    def __init__(self, message: str, resource: str = None):
        super().__init__(message, "CONFLICT")
        self.resource = resource


class BusinessRuleException(DomainException):
    """Excepci√≥n para violaciones de reglas de negocio."""
    
    def __init__(self, message: str, rule: str = None):
        super().__init__(message, "BUSINESS_RULE_VIOLATION")
        self.rule = rule


class InfrastructureException(DomainException):
    """Excepci√≥n para errores de infraestructura."""
    
    def __init__(self, message: str, component: str = None):
        super().__init__(message, "INFRASTRUCTURE_ERROR")
        self.component = component


# Excepciones espec√≠ficas del dominio de usuarios
class UserAlreadyExistsException(ConflictException):
    """Excepci√≥n cuando un usuario ya existe."""
    
    def __init__(self, email: str):
        super().__init__(f"Usuario con email '{email}' ya existe", "User")
        self.email = email


class UserNotFoundException(NotFoundException):
    """Excepci√≥n cuando un usuario no se encuentra."""
    
    def __init__(self, identifier: str = None):
        super().__init__("Usuario", identifier)


class UserInactiveException(BusinessRuleException):
    """Excepci√≥n cuando un usuario est√° inactivo."""
    
    def __init__(self, user_id: str = None):
        message = "Usuario inactivo"
        if user_id:
            message = f"Usuario con ID '{user_id}' est√° inactivo"
        super().__init__(message, "user_active_required")


class InvalidCredentialsException(AuthenticationException):
    """Excepci√≥n para credenciales inv√°lidas."""
    
    def __init__(self):
        super().__init__("Email o contrase√±a incorrectos")


class TokenExpiredException(AuthenticationException):
    """Excepci√≥n para tokens expirados."""
    
    def __init__(self):
        super().__init__("Token expirado")


class InvalidTokenException(AuthenticationException):
    """Excepci√≥n para tokens inv√°lidos."""
    
    def __init__(self):
        super().__init__("Token inv√°lido")
>>>> app/core/security.py
"""
Configuraci√≥n de seguridad y autenticaci√≥n JWT.
Maneja la verificaci√≥n de tokens y dependencias de autenticaci√≥n.
"""
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from typing import Optional
from app.infrastructure.auth.jwt_handler import jwt_handler
from app.infrastructure.db.user_model import user_model
from app.domain.user.user_entity import User

# Esquema de seguridad Bearer Token
security = HTTPBearer()

class SecurityService:
    """Servicio de seguridad para autenticaci√≥n y autorizaci√≥n."""
    
    @staticmethod
    async def get_current_user(
        credentials: HTTPAuthorizationCredentials = Depends(security)
    ) -> User:
        """
        Dependency para obtener el usuario actual autenticado.
        
        Args:
            credentials: Credenciales JWT del header Authorization
            
        Returns:
            Entidad User del usuario autenticado
            
        Raises:
            HTTPException: Si el token es inv√°lido o el usuario no existe
        """
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        
        try:
            # Verificar y decodificar token
            payload = jwt_handler.verify_token(credentials.credentials)
            if payload is None:
                raise credentials_exception
            
            user_id: str = payload.get("user_id")
            if user_id is None:
                raise credentials_exception
            
        except Exception:
            raise credentials_exception
        
        # Buscar usuario en la base de datos
        user = await user_model.get_by_id(user_id)
        if user is None:
            raise credentials_exception
        
        # Verificar que el usuario est√© activo
        if not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Inactive user"
            )
        
        return user
    
    @staticmethod
    async def get_current_active_user(
        current_user: User = Depends(get_current_user)
    ) -> User:
        """
        Dependency para obtener el usuario actual activo.
        Es un wrapper adicional para mayor claridad en los endpoints.
        
        Args:
            current_user: Usuario actual obtenido del token
            
        Returns:
            Entidad User del usuario activo
            
        Raises:
            HTTPException: Si el usuario est√° inactivo
        """
        if not current_user.is_active:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Inactive user"
            )
        return current_user
    
    @staticmethod
    def verify_token_without_exception(token: str) -> Optional[dict]:
        """
        Verifica un token JWT sin lanzar excepciones.
        √ötil para casos donde necesitamos verificar tokens opcionalmente.
        
        Args:
            token: Token JWT a verificar
            
        Returns:
            Payload del token si es v√°lido, None si es inv√°lido
        """
        return jwt_handler.verify_token(token)
    
    @staticmethod
    async def get_user_from_token(token: str) -> Optional[User]:
        """
        Obtiene un usuario directamente desde un token JWT.
        
        Args:
            token: Token JWT
            
        Returns:
            Entidad User si el token es v√°lido y el usuario existe, None en caso contrario
        """
        payload = SecurityService.verify_token_without_exception(token)
        if not payload:
            return None
        
        user_id = payload.get("user_id")
        if not user_id:
            return None
        
        user = await user_model.get_by_id(user_id)
        if not user or not user.is_active:
            return None
        
        return user

# Instancia global del servicio de seguridad
security_service = SecurityService()

# Funci√≥n de conveniencia para dependency injection
async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> User:
    """Dependency function para obtener el usuario actual."""
    return await security_service.get_current_user(credentials)

async def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """Dependency function para obtener el usuario actual activo."""
    return await security_service.get_current_active_user(current_user)

# Funciones adicionales de utilidad
def create_token_response_data(token: str, user: User) -> dict:
    """
    Crea los datos de respuesta para un token JWT.
    
    Args:
        token: Token JWT generado
        user: Entidad User
        
    Returns:
        Diccionario con datos del token y usuario
    """
    from app.core.config import settings
    
    return {
        "access_token": token,
        "token_type": "bearer",
        "expires_in": settings.JWT_EXPIRATION_TIME_MINUTES,
        "user_id": user.id,
        "email": user.email
    }
>>>> app/core/utils.py
"""
Funciones auxiliares generales.
Funciones de utilidad que se usan en toda la aplicaci√≥n.
"""
import re
from datetime import datetime
from typing import Any, Dict, Optional
import uuid

class ValidationUtils:
    """Utilidades para validaci√≥n de datos."""
    
    @staticmethod
    def is_valid_email(email: str) -> bool:
        """
        Valida si un email tiene formato correcto.
        
        Args:
            email: Email a validar
            
        Returns:
            True si es v√°lido, False en caso contrario
        """
        if not email:
            return False
        
        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(email_pattern, email) is not None
    
    @staticmethod
    def is_valid_password(password: str) -> bool:
        """
        Valida si una contrase√±a cumple los requisitos m√≠nimos.
        
        Args:
            password: Contrase√±a a validar
            
        Returns:
            True si es v√°lida, False en caso contrario
        """
        if not password:
            return False
        
        return len(password) >= 6 and len(password) <= 128
    
    @staticmethod
    def is_valid_uuid(uuid_string: str) -> bool:
        """
        Valida si un string es un UUID v√°lido.
        
        Args:
            uuid_string: String a validar
            
        Returns:
            True si es un UUID v√°lido, False en caso contrario
        """
        try:
            uuid.UUID(uuid_string)
            return True
        except ValueError:
            return False

class DateUtils:
    """Utilidades para manejo de fechas."""
    
    @staticmethod
    def get_current_utc() -> datetime:
        """
        Obtiene la fecha y hora actual en UTC.
        
        Returns:
            Datetime actual en UTC
        """
        return datetime.utcnow()
    
    @staticmethod
    def format_datetime(dt: datetime) -> str:
        """
        Formatea un datetime a string ISO.
        
        Args:
            dt: Datetime a formatear
            
        Returns:
            String en formato ISO
        """
        return dt.isoformat()
    
    @staticmethod
    def parse_datetime(dt_string: str) -> Optional[datetime]:
        """
        Parsea un string de fecha a datetime.
        
        Args:
            dt_string: String de fecha en formato ISO
            
        Returns:
            Datetime parseado o None si es inv√°lido
        """
        try:
            return datetime.fromisoformat(dt_string)
        except ValueError:
            return None

class ResponseUtils:
    """Utilidades para manejo de respuestas de API."""
    
    @staticmethod
    def success_response(
        message: str = "Operation successful",
        data: Optional[Any] = None
    ) -> Dict[str, Any]:
        """
        Crea una respuesta de √©xito est√°ndar.
        
        Args:
            message: Mensaje de √©xito
            data: Datos adicionales (opcional)
            
        Returns:
            Diccionario con respuesta de √©xito
        """
        response = {
            "success": True,
            "message": message,
            "timestamp": DateUtils.get_current_utc().isoformat()
        }
        
        if data is not None:
            response["data"] = data
        
        return response
    
    @staticmethod
    def error_response(
        message: str,
        error_code: Optional[str] = None,
        details: Optional[Any] = None
    ) -> Dict[str, Any]:
        """
        Crea una respuesta de error est√°ndar.
        
        Args:
            message: Mensaje de error
            error_code: C√≥digo de error (opcional)
            details: Detalles adicionales (opcional)
            
        Returns:
            Diccionario con respuesta de error
        """
        response = {
            "success": False,
            "error": message,
            "timestamp": DateUtils.get_current_utc().isoformat()
        }
        
        if error_code:
            response["error_code"] = error_code
        
        if details:
            response["details"] = details
        
        return response

class StringUtils:
    """Utilidades para manejo de strings."""
    
    @staticmethod
    def normalize_email(email: str) -> str:
        """
        Normaliza un email (lowercase y trim).
        
        Args:
            email: Email a normalizar
            
        Returns:
            Email normalizado
        """
        if not email:
            return ""
        
        return email.lower().strip()
    
    @staticmethod
    def generate_uuid() -> str:
        """
        Genera un UUID √∫nico.
        
        Returns:
            UUID como string
        """
        return str(uuid.uuid4())
    
    @staticmethod
    def sanitize_string(text: str, max_length: int = 255) -> str:
        """
        Sanitiza un string eliminando caracteres no deseados.
        
        Args:
            text: Texto a sanitizar
            max_length: Longitud m√°xima
            
        Returns:
            String sanitizado
        """
        if not text:
            return ""
        
        # Trim y limitar longitud
        sanitized = text.strip()[:max_length]
        
        return sanitized

class PaginationUtils:
    """Utilidades para paginaci√≥n."""
    
    @staticmethod
    def validate_pagination_params(skip: int, limit: int) -> tuple[int, int]:
        """
        Valida y normaliza par√°metros de paginaci√≥n.
        
        Args:
            skip: Registros a saltar
            limit: L√≠mite de registros
            
        Returns:
            Tupla con (skip, limit) validados
        """
        # Validar skip
        if skip < 0:
            skip = 0
        
        # Validar limit
        if limit < 1:
            limit = 20
        elif limit > 100:
            limit = 100
        
        return skip, limit
    
    @staticmethod
    def calculate_pagination_info(
        total: int,
        skip: int,
        limit: int,
        current_count: int
    ) -> Dict[str, Any]:
        """
        Calcula informaci√≥n de paginaci√≥n.
        
        Args:
            total: Total de registros
            skip: Registros saltados
            limit: L√≠mite de registros
            current_count: Registros en la p√°gina actual
            
        Returns:
            Diccionario con informaci√≥n de paginaci√≥n
        """
        has_more = skip + current_count < total
        current_page = (skip // limit) + 1
        total_pages = (total + limit - 1) // limit  # Ceiling division
        
        return {
            "total": total,
            "skip": skip,
            "limit": limit,
            "current_count": current_count,
            "has_more": has_more,
            "current_page": current_page,
            "total_pages": total_pages
        }

# Instancias globales de utilidades
validation_utils = ValidationUtils()
date_utils = DateUtils()
response_utils = ResponseUtils()
string_utils = StringUtils()
pagination_utils = PaginationUtils()
>>>> app/domain/user/user_entity.py
from datetime import datetime
from typing import Optional
from app.core.utils import string_utils, date_utils

class User:
    def __init__(self, id: str, email: str, password_hash: str,
                 is_active: bool = True,
                 created_at: Optional[datetime] = None,
                 updated_at: Optional[datetime] = None):
        self.id = id
        self.email = email
        self.password_hash = password_hash
        self.is_active = is_active
        self.created_at = created_at or date_utils.get_current_utc()
        self.updated_at = updated_at or date_utils.get_current_utc()

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "email": self.email,
            "password_hash": self.password_hash,
            "is_active": self.is_active,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }

    @classmethod
    def from_dict(cls, data: dict) -> "User":
        return cls(
            id=data["id"],
            email=data["email"],
            password_hash=data["password_hash"],
            is_active=data.get("is_active", True),
            created_at=date_utils.parse_datetime(data.get("created_at")),
            updated_at=date_utils.parse_datetime(data.get("updated_at"))
        )

    @classmethod
    def create_new_user(cls, email: str, password_hash: str) -> "User":
        return cls(
            id=string_utils.generate_uuid(),
            email=email,
            password_hash=password_hash
        )

    def deactivate(self):
        """Desactiva el usuario (soft delete)"""
        self.is_active = False
        self.updated_at = date_utils.get_current_utc()

    def activate(self):
        """Activa el usuario"""
        self.is_active = True
        self.updated_at = date_utils.get_current_utc()

    def update_email(self, new_email: str):
        """Actualiza el email del usuario"""
        if not new_email or not new_email.strip():
            raise ValueError("Email no puede estar vac√≠o")
        
        self.email = string_utils.normalize_email(new_email)
        self.updated_at = date_utils.get_current_utc()

    def update_password_hash(self, new_password_hash: str):
        """Actualiza el hash de la contrase√±a"""
        if not new_password_hash:
            raise ValueError("Password hash no puede estar vac√≠o")
        
        self.password_hash = new_password_hash
        self.updated_at = date_utils.get_current_utc()

    def to_public_dict(self) -> dict:
        """Devuelve datos p√∫blicos del usuario (sin password_hash)"""
        return {
            "id": self.id,
            "email": self.email,
            "is_active": self.is_active,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }
>>>> app/infrastructure/auth/jwt_handler.py
"""
Manejador de JWT para autenticaci√≥n.
Genera y valida tokens JWT.
"""
import jwt
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from app.core.config import settings

class JWTHandler:
    """Manejador de tokens JWT."""
    
    @staticmethod
    def create_access_token(user_id: str, email: str) -> str:
        """
        Crea un token JWT de acceso.
        
        Args:
            user_id: ID del usuario
            email: Email del usuario
            
        Returns:
            Token JWT como string
        """
        # Tiempo de expiraci√≥n
        expire = datetime.utcnow() + timedelta(
            minutes=settings.JWT_EXPIRATION_TIME_MINUTES
        )
        
        # Payload del token
        payload = {
            "user_id": user_id,
            "email": email,
            "exp": expire,
            "iat": datetime.utcnow(),
            "type": "access"
        }
        
        # Generar token
        token = jwt.encode(
            payload,
            settings.JWT_SECRET_KEY,
            algorithm=settings.JWT_ALGORITHM
        )
        
        return token
    
    @staticmethod
    def verify_token(token: str) -> Optional[Dict[str, Any]]:
        """
        Verifica y decodifica un token JWT.
        
        Args:
            token: Token JWT a verificar
            
        Returns:
            Payload del token si es v√°lido, None si es inv√°lido
        """
        try:
            payload = jwt.decode(
                token,
                settings.JWT_SECRET_KEY,
                algorithms=[settings.JWT_ALGORITHM]
            )
            
            # Verificar que sea un token de acceso
            if payload.get("type") != "access":
                return None
                
            return payload
            
        except jwt.ExpiredSignatureError:
            # Token expirado
            return None
        except jwt.InvalidTokenError:
            # Token inv√°lido
            return None
    
    @staticmethod
    def get_user_id_from_token(token: str) -> Optional[str]:
        """
        Extrae el user_id de un token JWT v√°lido.
        
        Args:
            token: Token JWT
            
        Returns:
            user_id si el token es v√°lido, None en caso contrario
        """
        payload = JWTHandler.verify_token(token)
        if payload:
            return payload.get("user_id")
        return None
    
    @staticmethod
    def is_token_expired(token: str) -> bool:
        """
        Verifica si un token ha expirado.
        
        Args:
            token: Token JWT
            
        Returns:
            True si ha expirado, False en caso contrario
        """
        try:
            jwt.decode(
                token,
                settings.JWT_SECRET_KEY,
                algorithms=[settings.JWT_ALGORITHM]
            )
            return False
        except jwt.ExpiredSignatureError:
            return True
        except jwt.InvalidTokenError:
            return True

# Instancia global del JWT handler
jwt_handler = JWTHandler()
>>>> app/infrastructure/auth/password_hashing.py
"""
Servicio de hashing y verificaci√≥n de contrase√±as.
Abstrae la l√≥gica de hash de contrase√±as usando bcrypt.
"""
import bcrypt

class PasswordHasher:
    """Manejador de hash y verificaci√≥n de contrase√±as."""
    
    @staticmethod
    def hash_password(password: str) -> str:
        """
        Genera un hash seguro de la contrase√±a.
        
        Args:
            password: Contrase√±a en texto plano
            
        Returns:
            Hash de la contrase√±a como string
        """
        if not password:
            raise ValueError("Password no puede estar vac√≠o")
        
        # Generar salt y hash
        salt = bcrypt.gensalt()
        password_bytes = password.encode('utf-8')
        hash_bytes = bcrypt.hashpw(password_bytes, salt)
        
        return hash_bytes.decode('utf-8')
    
    @staticmethod
    def verify_password(password: str, hashed_password: str) -> bool:
        """
        Verifica si una contrase√±a coincide con su hash.
        
        Args:
            password: Contrase√±a en texto plano
            hashed_password: Hash almacenado
            
        Returns:
            True si la contrase√±a es correcta, False en caso contrario
        """
        if not password or not hashed_password:
            return False
        
        try:
            password_bytes = password.encode('utf-8')
            hashed_bytes = hashed_password.encode('utf-8')
            return bcrypt.checkpw(password_bytes, hashed_bytes)
        except (ValueError, TypeError):
            return False

# Instancia global del hasher
password_hasher = PasswordHasher()
>>>> app/infrastructure/db/mongo_client.py
"""
Cliente real de MongoDB usando Motor (driver as√≠ncrono).
Reemplaza el cliente mock con una implementaci√≥n real de MongoDB.
"""
from typing import Dict, List, Optional, Any
from datetime import datetime
import logging
from motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase, AsyncIOMotorCollection
from pymongo.errors import ServerSelectionTimeoutError, DuplicateKeyError
from app.domain.user.user_entity import User
from app.core.config import settings

logger = logging.getLogger(__name__)

class MongoClient:
    """
    Cliente real de MongoDB para operaciones as√≠ncronas.
    Maneja conexiones y operaciones CRUD con la base de datos.
    """
    
    def __init__(self):
        self._client: Optional[AsyncIOMotorClient] = None
        self._database: Optional[AsyncIOMotorDatabase] = None
        self._users_collection: Optional[AsyncIOMotorCollection] = None
        self._connected = False
    
    async def connect(self) -> bool:
        """
        Establece conexi√≥n con MongoDB.
        
        Returns:
            True si la conexi√≥n es exitosa, False en caso contrario
        """
        try:
            # Crear cliente de MongoDB
            self._client = AsyncIOMotorClient(
                settings.MONGODB_URL,
                serverSelectionTimeoutMS=5000  # 5 segundos timeout
            )
            
            # Verificar conexi√≥n
            await self._client.admin.command('ping')
            
            # Configurar base de datos y colecciones
            self._database = self._client[settings.DATABASE_NAME]
            self._users_collection = self._database[settings.USERS_COLLECTION]
            
            # Crear √≠ndices
            await self._create_indexes()
            
            self._connected = True
            logger.info("‚úÖ Conectado exitosamente a MongoDB")
            return True
            
        except ServerSelectionTimeoutError:
            logger.error("‚ùå No se pudo conectar a MongoDB: Timeout")
            return False
        except Exception as e:
            logger.error(f"‚ùå Error al conectar a MongoDB: {e}")
            return False
    
    async def disconnect(self) -> None:
        """Cierra la conexi√≥n con MongoDB."""
        if self._client:
            self._client.close()
            self._connected = False
            logger.info("üîå Desconectado de MongoDB")
    
    def is_connected(self) -> bool:
        """Verifica si est√° conectado a MongoDB."""
        return self._connected and self._client is not None
    
    async def _create_indexes(self) -> None:
        """Crea √≠ndices necesarios en las colecciones."""
        try:
            # √çndice √∫nico en email
            await self._users_collection.create_index("email", unique=True)
            # √çndice en is_active para consultas eficientes
            await self._users_collection.create_index("is_active")
            logger.info("‚úÖ √çndices creados exitosamente")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error al crear √≠ndices: {e}")
    
    # Operaciones de usuarios
    async def create_user(self, user: User) -> bool:
        """
        Crea un nuevo usuario en la base de datos.
        
        Args:
            user: Entidad User a crear
            
        Returns:
            True si se cre√≥ exitosamente
            
        Raises:
            ConnectionError: Si no est√° conectado
            ValueError: Si el usuario ya existe
        """
        if not self.is_connected():
            raise ConnectionError("Database not connected")
        
        try:
            user_doc = user.to_dict()
            await self._users_collection.insert_one(user_doc)
            logger.info(f"‚úÖ Usuario creado: {user.email}")
            return True
            
        except DuplicateKeyError:
            logger.warning(f"‚ö†Ô∏è Usuario ya existe: {user.email}")
            raise ValueError(f"Usuario con email {user.email} ya existe")
        except Exception as e:
            logger.error(f"‚ùå Error al crear usuario: {e}")
            raise RuntimeError(f"Error al crear usuario: {e}")
    
    async def get_user_by_id(self, user_id: str) -> Optional[User]:
        """
        Obtiene un usuario por su ID.
        
        Args:
            user_id: ID del usuario
            
        Returns:
            Entidad User si existe, None en caso contrario
        """
        if not self.is_connected():
            raise ConnectionError("Database not connected")
        
        try:
            user_doc = await self._users_collection.find_one({"id": user_id})
            if user_doc:
                # Remover el _id de MongoDB antes de crear la entidad
                user_doc.pop('_id', None)
                return User.from_dict(user_doc)
            return None
            
        except Exception as e:
            logger.error(f"‚ùå Error al obtener usuario por ID {user_id}: {e}")
            return None
    
    async def get_user_by_email(self, email: str) -> Optional[User]:
        """
        Obtiene un usuario por su email.
        
        Args:
            email: Email del usuario
            
        Returns:
            Entidad User si existe, None en caso contrario
        """
        if not self.is_connected():
            raise ConnectionError("Database not connected")
        
        try:
            email = email.lower().strip()
            user_doc = await self._users_collection.find_one({"email": email})
            if user_doc:
                # Remover el _id de MongoDB antes de crear la entidad
                user_doc.pop('_id', None)
                return User.from_dict(user_doc)
            return None
            
        except Exception as e:
            logger.error(f"‚ùå Error al obtener usuario por email {email}: {e}")
            return None
    
    async def get_all_users(self, skip: int = 0, limit: int = 100) -> List[User]:
        """
        Obtiene todos los usuarios con paginaci√≥n.
        
        Args:
            skip: N√∫mero de registros a saltar
            limit: L√≠mite de registros a retornar
            
        Returns:
            Lista de entidades User
        """
        if not self.is_connected():
            raise ConnectionError("Database not connected")
        
        try:
            cursor = self._users_collection.find({}).skip(skip).limit(limit)
            users = []
            
            async for user_doc in cursor:
                # Remover el _id de MongoDB antes de crear la entidad
                user_doc.pop('_id', None)
                users.append(User.from_dict(user_doc))
            
            return users
            
        except Exception as e:
            logger.error(f"‚ùå Error al obtener usuarios: {e}")
            return []
    
    async def update_user(self, user: User) -> bool:
        """
        Actualiza un usuario existente.
        
        Args:
            user: Entidad User con datos actualizados
            
        Returns:
            True si se actualiz√≥ exitosamente
        """
        if not self.is_connected():
            raise ConnectionError("Database not connected")
        
        try:
            user.updated_at = datetime.utcnow()
            user_doc = user.to_dict()
            
            result = await self._users_collection.replace_one(
                {"id": user.id},
                user_doc
            )
            
            if result.modified_count > 0:
                logger.info(f"‚úÖ Usuario actualizado: {user.email}")
                return True
            else:
                logger.warning(f"‚ö†Ô∏è Usuario no encontrado para actualizar: {user.id}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error al actualizar usuario {user.id}: {e}")
            return False
    
    async def delete_user(self, user_id: str) -> bool:
        """
        Elimina un usuario (hard delete).
        
        Args:
            user_id: ID del usuario a eliminar
            
        Returns:
            True si se elimin√≥ exitosamente
        """
        if not self.is_connected():
            raise ConnectionError("Database not connected")
        
        try:
            result = await self._users_collection.delete_one({"id": user_id})
            
            if result.deleted_count > 0:
                logger.info(f"‚úÖ Usuario eliminado: {user_id}")
                return True
            else:
                logger.warning(f"‚ö†Ô∏è Usuario no encontrado para eliminar: {user_id}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error al eliminar usuario {user_id}: {e}")
            return False
    
    async def count_users(self) -> int:
        """
        Cuenta el total de usuarios.
        
        Returns:
            N√∫mero total de usuarios
        """
        if not self.is_connected():
            raise ConnectionError("Database not connected")
        
        try:
            count = await self._users_collection.count_documents({})
            return count
            
        except Exception as e:
            logger.error(f"‚ùå Error al contar usuarios: {e}")
            return 0
    
    async def count_active_users(self) -> int:
        """
        Cuenta el total de usuarios activos.
        
        Returns:
            N√∫mero total de usuarios activos
        """
        if not self.is_connected():
            raise ConnectionError("Database not connected")
        
        try:
            count = await self._users_collection.count_documents({"is_active": True})
            return count
            
        except Exception as e:
            logger.error(f"‚ùå Error al contar usuarios activos: {e}")
            return 0
    
    async def clear_all_users(self) -> None:
        """
        Limpia todos los usuarios (√∫til para testing).
        ‚ö†Ô∏è USAR SOLO EN DESARROLLO/TESTING
        """
        if not self.is_connected():
            raise ConnectionError("Database not connected")
        
        if settings.ENVIRONMENT == "production":
            raise RuntimeError("No se puede limpiar usuarios en producci√≥n")
        
        try:
            await self._users_collection.delete_many({})
            logger.warning("üóëÔ∏è Todos los usuarios han sido eliminados")
            
        except Exception as e:
            logger.error(f"‚ùå Error al limpiar usuarios: {e}")

# Instancia global del cliente MongoDB
mongo_client = MongoClient()
>>>> app/infrastructure/db/user_model.py
"""
Modelo de User para la capa de infraestructura.
Abstrae las operaciones de base de datos para la entidad User.
"""
from typing import List, Optional
from app.domain.user.user_entity import User
from app.infrastructure.db.mongo_client import mongo_client
from app.core.exceptions import (
    InfrastructureException,
    ConflictException,
    NotFoundException
)
import logging

logger = logging.getLogger(__name__)

class UserModel:
    """
    Modelo que encapsula las operaciones de base de datos para User.
    Act√∫a como repositorio para la entidad User.
    """
    
    def __init__(self):
        self.db = mongo_client
    
    async def create(self, user: User) -> User:
        """
        Crea un nuevo usuario en la base de datos.
        
        Args:
            user: Entidad User a crear
            
        Returns:
            Entidad User creada
            
        Raises:
            ConflictException: Si el usuario ya existe
            InfrastructureException: Si hay error de infraestructura
        """
        try:
            # Verificar si el email ya existe
            existing_user = await self.db.get_user_by_email(user.email)
            if existing_user:
                raise ConflictException(f"Usuario con email {user.email} ya existe", "User")
            
            # Crear usuario
            success = await self.db.create_user(user)
            if not success:
                raise InfrastructureException("Error al crear usuario", "database")
            
            logger.info(f"‚úÖ Usuario creado exitosamente: {user.email}")
            return user
            
        except ConflictException:
            # Re-lanzar excepciones de conflicto
            raise
        except ValueError as e:
            # Convertir ValueError de la DB a ConflictException
            if "ya existe" in str(e):
                raise ConflictException(str(e), "User")
            raise InfrastructureException(str(e), "database")
        except Exception as e:
            logger.error(f"‚ùå Error al crear usuario: {e}")
            raise InfrastructureException(f"Error al crear usuario: {str(e)}", "database")
    
    async def get_by_id(self, user_id: str) -> Optional[User]:
        """
        Obtiene un usuario por su ID.
        
        Args:
            user_id: ID del usuario
            
        Returns:
            Entidad User si existe, None en caso contrario
        """
        try:
            return await self.db.get_user_by_id(user_id)
        except Exception as e:
            logger.error(f"‚ùå Error al obtener usuario por ID {user_id}: {e}")
            raise InfrastructureException(f"Error al obtener usuario: {str(e)}", "database")
    
    async def get_by_email(self, email: str) -> Optional[User]:
        """
        Obtiene un usuario por su email.
        
        Args:
            email: Email del usuario
            
        Returns:
            Entidad User si existe, None en caso contrario
        """
        try:
            return await self.db.get_user_by_email(email)
        except Exception as e:
            logger.error(f"‚ùå Error al obtener usuario por email {email}: {e}")
            raise InfrastructureException(f"Error al obtener usuario: {str(e)}", "database")
    
    async def get_all(self, skip: int = 0, limit: int = 100) -> List[User]:
        """
        Obtiene todos los usuarios con paginaci√≥n.
        
        Args:
            skip: N√∫mero de registros a saltar
            limit: L√≠mite de registros a retornar
            
        Returns:
            Lista de entidades User
        """
        try:
            return await self.db.get_all_users(skip=skip, limit=limit)
        except Exception as e:
            logger.error(f"‚ùå Error al obtener usuarios: {e}")
            raise InfrastructureException(f"Error al obtener usuarios: {str(e)}", "database")
    
    async def update(self, user: User) -> User:
        """
        Actualiza un usuario existente.
        
        Args:
            user: Entidad User con datos actualizados
            
        Returns:
            Entidad User actualizada
            
        Raises:
            NotFoundException: Si el usuario no existe
            InfrastructureException: Si hay error de infraestructura
        """
        try:
            success = await self.db.update_user(user)
            if not success:
                raise NotFoundException("Usuario", user.id)
            
            logger.info(f"‚úÖ Usuario actualizado exitosamente: {user.email}")
            return user
            
        except Exception as e:
            logger.error(f"‚ùå Error al actualizar usuario {user.id}: {e}")
            raise InfrastructureException(f"Error al actualizar usuario: {str(e)}", "database")
    
    async def delete(self, user_id: str) -> bool:
        """
        Elimina un usuario por su ID.
        
        Args:
            user_id: ID del usuario a eliminar
            
        Returns:
            True si se elimin√≥ exitosamente
            
        Raises:
            NotFoundException: Si el usuario no existe
            InfrastructureException: Si hay error de infraestructura
        """
        try:
            success = await self.db.delete_user(user_id)
            if not success:
                raise NotFoundException("Usuario", user_id)
            
            logger.info(f"‚úÖ Usuario eliminado exitosamente: {user_id}")
            return True
            
        except NotFoundException:
            # Re-lanzar excepciones de not found
            raise
        except Exception as e:
            logger.error(f"‚ùå Error al eliminar usuario {user_id}: {e}")
            raise InfrastructureException(f"Error al eliminar usuario: {str(e)}", "database")
    
    async def exists_by_email(self, email: str) -> bool:
        """
        Verifica si existe un usuario con el email dado.
        
        Args:
            email: Email a verificar
            
        Returns:
            True si existe, False en caso contrario
        """
        try:
            user = await self.db.get_user_by_email(email)
            return user is not None
        except Exception as e:
            logger.error(f"‚ùå Error al verificar existencia de email {email}: {e}")
            # En caso de error, asumir que no existe para no bloquear operaciones
            return False
    
    async def count(self) -> int:
        """
        Cuenta el total de usuarios.
        
        Returns:
            N√∫mero total de usuarios
        """
        try:
            return await self.db.count_users()
        except Exception as e:
            logger.error(f"‚ùå Error al contar usuarios: {e}")
            raise InfrastructureException(f"Error al contar usuarios: {str(e)}", "database")
    
    async def count_active(self) -> int:
        """
        Cuenta el total de usuarios activos.
        
        Returns:
            N√∫mero total de usuarios activos
        """
        try:
            return await self.db.count_active_users()
        except Exception as e:
            logger.error(f"‚ùå Error al contar usuarios activos: {e}")
            raise InfrastructureException(f"Error al contar usuarios activos: {str(e)}", "database")

# Instancia global del modelo
user_model = UserModel()
>>>> app/interfaces/api/v1/api_v1.py
"""
Configuraci√≥n de la API v1.
Incluye todas las rutas de la versi√≥n 1 de la API.
"""
from fastapi import APIRouter
from app.interfaces.api.v1.routes.user_routes import router as user_router
from app.interfaces.api.v1.routes.auth_routes import router as auth_router

# Router principal para la API v1
api_router = APIRouter()

# Incluir rutas de autenticaci√≥n (sin autenticaci√≥n requerida)
api_router.include_router(
    auth_router,
    prefix="/auth",
    tags=["authentication"]
)

# Incluir rutas de usuarios (requieren autenticaci√≥n)
api_router.include_router(
    user_router,
    prefix="/users",
    tags=["users"]
)

# Endpoint de health check
@api_router.get(
    "/health",
    tags=["health"],
    summary="Health Check",
    description="Verifica el estado de la API"
)
async def health_check():
    """
    Endpoint de health check para verificar que la API est√° funcionando.
    
    Returns informaci√≥n b√°sica del estado del servicio.
    """
    return {
        "status": "healthy",
        "message": "API is running",
        "version": "1.0.0",
        "services": {
            "database": "connected",
            "authentication": "active"
        }
    }

# Endpoint de informaci√≥n de la API
@api_router.get(
    "/info",
    tags=["info"],
    summary="API Information",
    description="Informaci√≥n general sobre la API"
)
async def api_info():
    """
    Proporciona informaci√≥n general sobre la API.
    
    Returns metadatos de la API como versi√≥n, descripci√≥n, endpoints disponibles, etc.
    """
    return {
        "name": "Clients API",
        "version": "1.0.0",
        "description": "API REST para gesti√≥n de usuarios con autenticaci√≥n JWT",
        "architecture": "Clean Architecture",
        "features": [
            "Registro y autenticaci√≥n de usuarios",
            "CRUD completo de usuarios",
            "Autenticaci√≥n JWT",
            "Paginaci√≥n en listados",
            "Soft delete de usuarios",
            "Validaci√≥n con Pydantic",
            "Documentaci√≥n OpenAPI"
        ],
        "endpoints": {
            "authentication": [
                "POST /api/v1/auth/login",
                "POST /api/v1/auth/register"
            ],
            "users": [
                "POST /api/v1/users",
                "GET /api/v1/users/{id}",
                "GET /api/v1/users",
                "PUT /api/v1/users/{id}",
                "DELETE /api/v1/users/{id}"
            ],
            "utility": [
                "GET /api/v1/health",
                "GET /api/v1/info"
            ]
        },
        "authentication": {
            "type": "JWT Bearer Token",
            "header": "Authorization: Bearer <token>",
            "expiration": "30 minutes"
        },
        "documentation": {
            "swagger": "/docs",
            "redoc": "/redoc",
            "openapi": "/api/v1/openapi.json"
        },
        "status": "active"
    }
>>>> app/interfaces/api/v1/routes/auth_routes.py
"""
Rutas de autenticaci√≥n.
Maneja login, registro y operaciones de autenticaci√≥n.
"""
from fastapi import APIRouter, Depends, status
from app.controllers.user_controller import user_controller
from app.interfaces.schemas.user_request import (
    UserCreateRequest,
    UserLoginRequest
)
from app.interfaces.schemas.user_response import (
    UserCreateResponse,
    UserLoginResponse,
    ErrorResponse,
    user_to_response
)
from app.core.security import get_current_active_user
from app.core.exceptions import (
    ValidationException,
    AuthenticationException,
    ConflictException,
    InfrastructureException
)

# Router para autenticaci√≥n
router = APIRouter(tags=["authentication"])

@router.post(
    "/login",
    response_model=UserLoginResponse,
    summary="Iniciar sesi√≥n",
    description="Autentica un usuario con email y contrase√±a, devuelve un token JWT",
    responses={
        200: {"description": "Login exitoso", "model": UserLoginResponse},
        401: {"description": "Credenciales inv√°lidas"},
        400: {"description": "Datos de entrada inv√°lidos"},
        422: {"description": "Usuario inactivo"},
        500: {"description": "Error interno del servidor"}
    }
)
async def login(request: UserLoginRequest):
    """
    Autentica un usuario con email y contrase√±a.
    
    - **email**: Email del usuario registrado
    - **password**: Contrase√±a del usuario
    
    Devuelve un token JWT para autenticaci√≥n en futuras requests.
    
    **Nota**: Las excepciones se manejan autom√°ticamente por el sistema centralizado.
    """
    # Las excepciones espec√≠ficas del dominio se propagan autom√°ticamente
    # y son manejadas por el sistema centralizado de exception handlers
    result = await user_controller.login_user(request)
    return result

@router.post(
    "/register",
    response_model=UserCreateResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Registrar nuevo usuario",
    description="Crea una nueva cuenta de usuario",
    responses={
        201: {"description": "Usuario creado exitosamente", "model": UserCreateResponse},
        400: {"description": "Datos de entrada inv√°lidos"},
        409: {"description": "Usuario ya existe"},
        500: {"description": "Error interno del servidor"}
    }
)
async def register(request: UserCreateRequest):
    """
    Registra un nuevo usuario.
    
    - **email**: Email v√°lido y √∫nico
    - **password**: Contrase√±a (m√≠nimo 6 caracteres)
    
    Crea el usuario y devuelve la informaci√≥n b√°sica (sin contrase√±a).
    
    **Nota**: Las excepciones se manejan autom√°ticamente por el sistema centralizado.
    """
    # Las excepciones espec√≠ficas del dominio se propagan autom√°ticamente
    # y son manejadas por el sistema centralizado de exception handlers
    result = await user_controller.create_user(request)
    return result

@router.get(
    "/validate-token",
    summary="Validar token",
    description="Valida si un token JWT es v√°lido",
    responses={
        200: {"description": "Token v√°lido"},
        401: {"description": "Token inv√°lido o expirado"}
    }
)
async def validate_token(current_user = Depends(get_current_active_user)):
    """
    Valida el token JWT del usuario autenticado.
    
    **Requiere autenticaci√≥n JWT.**
    
    Endpoint √∫til para verificar si un token sigue siendo v√°lido.
    """
    user_response = user_to_response(current_user)
    return {
        "valid": True,
        "user": user_response,
        "message": "Token v√°lido"
    }
>>>> app/interfaces/api/v1/routes/user_routes.py
"""
Rutas de la API para operaciones CRUD de usuarios.
Define los endpoints REST para el manejo de usuarios autenticados.
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query
from typing import List
from app.controllers.user_controller import user_controller
from app.interfaces.schemas.user_request import (
    UserCreateRequest,
    UserUpdateRequest,
    UserQueryRequest
)
from app.interfaces.schemas.user_response import (
    UserCreateResponse,
    UserUpdateResponse,
    UserDeleteResponse,
    UserListResponse,
    ErrorResponse,
    user_to_response
)
from app.core.security import get_current_active_user
from app.domain.user.user_entity import User

# Router para las rutas de usuario (requieren autenticaci√≥n)
router = APIRouter(tags=["users"])

# IMPORTANTE: Las rutas espec√≠ficas deben ir ANTES que las rutas con par√°metros
# para evitar conflictos en FastAPI

@router.get(
    "/me/profile",
    response_model=dict,
    summary="Obtener perfil actual",
    description="Obtiene la informaci√≥n del usuario autenticado"
)
async def get_current_user_profile(
    current_user: User = Depends(get_current_active_user)
):
    """
    Obtiene el perfil del usuario autenticado.
    
    **Requiere autenticaci√≥n JWT.**
    
    Devuelve la informaci√≥n completa del usuario que est√° autenticado.
    """
    # Las excepciones se manejan autom√°ticamente por el sistema centralizado
    user = await user_controller.get_current_user_profile(current_user)
    user_response = user_to_response(user)
    return {
        "user": user_response,
        "message": "Perfil obtenido exitosamente"
    }

@router.get(
    "",
    response_model=UserListResponse,
    summary="Listar todos los usuarios",
    description="Obtiene una lista paginada de todos los usuarios"
)
async def list_all_users(
    skip: int = Query(0, ge=0, description="N√∫mero de registros a saltar"),
    limit: int = Query(20, ge=1, le=100, description="L√≠mite de registros por p√°gina"),
    current_user: User = Depends(get_current_active_user)
):
    """
    Lista todos los usuarios con paginaci√≥n.
    
    **Requiere autenticaci√≥n JWT.**
    
    - **skip**: N√∫mero de registros a saltar (default: 0)
    - **limit**: L√≠mite de registros por p√°gina (default: 20, max: 100)
    
    Devuelve informaci√≥n b√°sica de todos los usuarios activos.
    """
    # Las excepciones se manejan autom√°ticamente por el sistema centralizado
    query = UserQueryRequest(skip=skip, limit=limit)
    return await user_controller.list_users(query, current_user)

@router.post(
    "",
    response_model=UserCreateResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Crear nuevo usuario",
    description="Crea un nuevo usuario (endpoint administrativo)"
)
async def create_user(
    request: UserCreateRequest,
    current_user: User = Depends(get_current_active_user)
):
    """
    Crea un nuevo usuario.
    
    **Requiere autenticaci√≥n JWT.**
    
    - **email**: Email v√°lido del usuario
    - **password**: Contrase√±a (m√≠nimo 6 caracteres)
    
    Este endpoint est√° protegido y requiere autenticaci√≥n.
    """
    # Las excepciones se manejan autom√°ticamente por el sistema centralizado
    return await user_controller.create_user(request)

@router.get(
    "/{user_id}",
    response_model=dict,
    summary="Obtener usuario por ID",
    description="Obtiene informaci√≥n de un usuario espec√≠fico"
)
async def get_user_by_id(
    user_id: str,
    current_user: User = Depends(get_current_active_user)
):
    """
    Obtiene un usuario por su ID.
    
    **Requiere autenticaci√≥n JWT.**
    
    - **user_id**: ID √∫nico del usuario
    
    Los usuarios pueden ver informaci√≥n b√°sica de otros usuarios activos.
    """
    # Las excepciones se manejan autom√°ticamente por el sistema centralizado
    user = await user_controller.get_user_by_id(user_id, current_user)
    user_response = user_to_response(user)
    return {
        "user": user_response,
        "message": "Usuario obtenido exitosamente"
    }

@router.put(
    "/{user_id}",
    response_model=UserUpdateResponse,
    summary="Actualizar usuario",
    description="Actualiza la informaci√≥n de un usuario existente"
)
async def update_user(
    user_id: str,
    request: UserUpdateRequest,
    current_user: User = Depends(get_current_active_user)
):
    """
    Actualiza un usuario existente.
    
    **Requiere autenticaci√≥n JWT.**
    
    - **user_id**: ID √∫nico del usuario a actualizar
    - **email**: Nuevo email (opcional)
    - **password**: Nueva contrase√±a (opcional)
    
    Los usuarios solo pueden actualizar su propia informaci√≥n,
    salvo que tengan permisos administrativos.
    """
    # Las excepciones se manejan autom√°ticamente por el sistema centralizado
    return await user_controller.update_user(user_id, request, current_user)

@router.delete(
    "/{user_id}",
    response_model=UserDeleteResponse,
    summary="Eliminar usuario",
    description="Elimina un usuario del sistema"
)
async def delete_user(
    user_id: str,
    current_user: User = Depends(get_current_active_user)
):
    """
    Elimina un usuario del sistema.
    
    **Requiere autenticaci√≥n JWT.**
    
    - **user_id**: ID √∫nico del usuario a eliminar
    
    Por defecto realiza un soft delete (desactivaci√≥n).
    Los usuarios solo pueden eliminar su propia cuenta,
    salvo que tengan permisos administrativos.
    """
    # Las excepciones se manejan autom√°ticamente por el sistema centralizado
    return await user_controller.delete_user_soft(user_id, current_user)
>>>> app/interfaces/schemas/user_request.py
"""
Esquemas de request para operaciones de usuario.
Define la estructura de datos de entrada para la API.
"""
from pydantic import BaseModel, EmailStr, validator
from typing import Optional

class UserCreateRequest(BaseModel):
    """Esquema para crear un nuevo usuario."""
    
    email: EmailStr
    password: str
    
    @validator('password')
    def validate_password(cls, v):
        """Valida que la contrase√±a cumpla con los requisitos m√≠nimos."""
        if len(v) < 6:
            raise ValueError('Password debe tener al menos 6 caracteres')
        if len(v) > 128:
            raise ValueError('Password no puede tener m√°s de 128 caracteres')
        return v
    
    @validator('email')
    def validate_email(cls, v):
        """Valida y normaliza el email."""
        return v.lower().strip()

class UserLoginRequest(BaseModel):
    """Esquema para login de usuario."""
    
    email: EmailStr
    password: str
    
    @validator('email')
    def validate_email(cls, v):
        """Valida y normaliza el email."""
        return v.lower().strip()

class UserUpdateRequest(BaseModel):
    """Esquema para actualizar un usuario."""
    
    email: Optional[EmailStr] = None
    password: Optional[str] = None
    
    @validator('password')
    def validate_password(cls, v):
        """Valida que la contrase√±a cumpla con los requisitos m√≠nimos."""
        if v is not None:
            if len(v) < 6:
                raise ValueError('Password debe tener al menos 6 caracteres')
            if len(v) > 128:
                raise ValueError('Password no puede tener m√°s de 128 caracteres')
        return v
    
    @validator('email')
    def validate_email(cls, v):
        """Valida y normaliza el email."""
        if v is not None:
            return v.lower().strip()
        return v
    
    def has_updates(self) -> bool:
        """Verifica si hay campos para actualizar."""
        return any([
            self.email is not None,
            self.password is not None
        ])

class UserQueryRequest(BaseModel):
    """Esquema para consultas paginadas de usuarios."""
    
    skip: int = 0
    limit: int = 20
    
    @validator('skip')
    def validate_skip(cls, v):
        """Valida que skip sea no negativo."""
        if v < 0:
            raise ValueError('Skip debe ser mayor o igual a 0')
        return v
    
    @validator('limit')
    def validate_limit(cls, v):
        """Valida que limit est√© en un rango razonable."""
        if v < 1:
            raise ValueError('Limit debe ser mayor a 0')
        if v > 100:
            raise ValueError('Limit no puede ser mayor a 100')
        return v
>>>> app/interfaces/schemas/user_response.py
"""
Esquemas de response para operaciones de usuario.
Define la estructura de datos de salida de la API.
"""
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime

class UserResponse(BaseModel):
    """Esquema base de respuesta para usuario."""
    
    id: str
    email: str
    is_active: bool
    created_at: datetime
    updated_at: datetime
    
    class Config:
        """Configuraci√≥n del modelo Pydantic."""
        from_attributes = True
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

class UserCreateResponse(BaseModel):
    """Respuesta para creaci√≥n de usuario."""
    
    user: UserResponse
    message: str = "Usuario creado exitosamente"

class UserLoginResponse(BaseModel):
    """Respuesta para login de usuario."""
    
    access_token: str
    token_type: str = "bearer"
    user: UserResponse
    expires_in: int  # minutos hasta expiraci√≥n

class UserUpdateResponse(BaseModel):
    """Respuesta para actualizaci√≥n de usuario."""
    
    user: UserResponse
    message: str = "Usuario actualizado exitosamente"

class UserListResponse(BaseModel):
    """Respuesta para listado de usuarios."""
    
    users: List[UserResponse]
    total: int
    skip: int
    limit: int
    has_more: bool

class UserDeleteResponse(BaseModel):
    """Respuesta para eliminaci√≥n de usuario."""
    
    message: str = "Usuario eliminado exitosamente"
    deleted_id: str

class ErrorResponse(BaseModel):
    """Respuesta de error est√°ndar."""
    
    error: str
    message: str
    status_code: int

class SuccessResponse(BaseModel):
    """Respuesta de √©xito gen√©rica."""
    
    message: str
    success: bool = True

# Funciones de utilidad para convertir entidades a responses
def user_to_response(user) -> UserResponse:
    """Convierte una entidad User a UserResponse."""
    return UserResponse(
        id=user.id,
        email=user.email,
        is_active=user.is_active,
        created_at=user.created_at,
        updated_at=user.updated_at
    )

def users_to_list_response(
    users: List, 
    total: int, 
    skip: int, 
    limit: int
) -> UserListResponse:
    """Convierte una lista de usuarios a UserListResponse."""
    user_responses = [user_to_response(user) for user in users]
    has_more = skip + len(users) < total
    
    return UserListResponse(
        users=user_responses,
        total=total,
        skip=skip,
        limit=limit,
        has_more=has_more
    )
>>>> app/main.py
"""
Punto de entrada principal de la aplicaci√≥n FastAPI.
Configura la aplicaci√≥n, middleware, CORS, rutas y manejadores de excepciones.
"""
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from contextlib import asynccontextmanager
import uvicorn
import logging
import time
from datetime import datetime
from app.core.config import settings
from app.interfaces.api.v1.api_v1 import api_router
from app.infrastructure.db.mongo_client import mongo_client
from app.core.exception_handlers import EXCEPTION_HANDLERS

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Maneja el ciclo de vida de la aplicaci√≥n.
    Se ejecuta al iniciar y al cerrar la aplicaci√≥n.
    """
    # Startup: Conectar a la base de datos
    logger.info("üöÄ Iniciando aplicaci√≥n...")
    try:
        success = await mongo_client.connect()
        if success:
            logger.info("‚úÖ Conectado exitosamente a MongoDB")
            logger.info(f"üìä Base de datos: {settings.DATABASE_NAME}")
            logger.info(f"üîó URL: {settings.MONGODB_URL}")
        else:
            logger.error("‚ùå No se pudo conectar a MongoDB")
            logger.error("‚ö†Ô∏è  La aplicaci√≥n continuar√° pero las operaciones de BD fallar√°n")
    except Exception as e:
        logger.error(f"‚ùå Error al conectar a MongoDB: {e}")
        logger.error("‚ö†Ô∏è  La aplicaci√≥n continuar√° pero las operaciones de BD fallar√°n")
    
    yield
    
    # Shutdown: Cerrar conexiones
    logger.info("üõë Cerrando aplicaci√≥n...")
    try:
        await mongo_client.disconnect()
        logger.info("‚úÖ Desconectado de MongoDB")
    except Exception as e:
        logger.error(f"‚ùå Error al desconectar de MongoDB: {e}")

# Crear instancia de FastAPI
app = FastAPI(
    title=settings.PROJECT_NAME,
    version=settings.PROJECT_VERSION,
    description="""
    ## Clients API - Clean Architecture Implementation
    
    API REST para gesti√≥n de usuarios con autenticaci√≥n JWT implementada siguiendo 
    principios de Clean Architecture.
    
    ### üèóÔ∏è Arquitectura
    
    - **Domain Layer**: Entidades y l√≥gica de negocio pura
    - **Application Layer**: Casos de uso y orquestaci√≥n
    - **Infrastructure Layer**: Implementaciones concretas (BD, Auth, etc.)
    - **Presentation Layer**: Controllers y API endpoints
    
    ### ‚ú® Caracter√≠sticas principales
    
    * **üîê Autenticaci√≥n JWT**: Sistema seguro de tokens Bearer
    * **üë• CRUD de Usuarios**: Operaciones completas de gesti√≥n
    * **üìù Validaci√≥n robusta**: Validaciones con Pydantic y reglas de negocio
    * **üõ°Ô∏è Seguridad**: Contrase√±as hasheadas con bcrypt
    * **üìä Paginaci√≥n**: Listados eficientes con paginaci√≥n
    * **üóëÔ∏è Soft Delete**: Desactivaci√≥n de usuarios sin p√©rdida de datos
    * **üö® Manejo de errores**: Sistema centralizado de excepciones
    * **üìñ Documentaci√≥n**: OpenAPI/Swagger completa
    * **üçÉ MongoDB**: Base de datos NoSQL para almacenamiento persistente
    
    ### üîó Endpoints principales
    
    #### Autenticaci√≥n (p√∫blico)
    - `POST /api/v1/auth/register` - Registrar nuevo usuario
    - `POST /api/v1/auth/login` - Iniciar sesi√≥n
    - `GET /api/v1/auth/validate-token` - Validar token JWT
    
    #### Usuarios (requiere autenticaci√≥n)
    - `POST /api/v1/users` - Crear usuario
    - `GET /api/v1/users/{id}` - Obtener usuario por ID
    - `GET /api/v1/users` - Listar usuarios
    - `PUT /api/v1/users/{id}` - Actualizar usuario
    - `DELETE /api/v1/users/{id}` - Eliminar usuario
    - `GET /api/v1/users/me/profile` - Obtener perfil propio
    
    ### üîë Autenticaci√≥n
    
    Para acceder a endpoints protegidos, incluye el token JWT:
    ```
    Authorization: Bearer <tu_token_jwt>
    ```
    
    ### üöÄ Inicio r√°pido
    
    1. **Registrarse**: `POST /api/v1/auth/register`
    2. **Iniciar sesi√≥n**: `POST /api/v1/auth/login`
    3. **Usar token**: Incluir en header `Authorization: Bearer <token>`
    4. **Explorar API**: Usar los endpoints protegidos
    
    ### üìä C√≥digos de respuesta
    
    - `200` - Operaci√≥n exitosa
    - `201` - Recurso creado
    - `400` - Datos de entrada inv√°lidos
    - `401` - No autenticado
    - `403` - Sin permisos
    - `404` - Recurso no encontrado
    - `409` - Conflicto (ej: email ya existe)
    - `422` - Error de reglas de negocio
    - `500` - Error interno del servidor
    
    ### üè≠ Base de datos
    
    - **MongoDB**: Base de datos NoSQL
    - **Motor**: Driver as√≠ncrono para Python
    - **√çndices optimizados**: Para consultas eficientes
    - **Conexi√≥n persistente**: Manejo autom√°tico de conexiones
    """,
    openapi_url=f"{settings.API_V1_PREFIX}/openapi.json",
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan
)

# Configurar CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["*"],
)

# Registrar manejadores de excepciones
for exception_type, handler in EXCEPTION_HANDLERS.items():
    app.add_exception_handler(exception_type, handler)

# Incluir rutas de la API v1
app.include_router(
    api_router,
    prefix=settings.API_V1_PREFIX
)

# Middleware para logging de requests
@app.middleware("http")
async def log_requests(request: Request, call_next):
    """Middleware para logging de todas las requests."""
    start_time = time.time()
    
    # Log request
    logger.info(f"üì• {request.method} {request.url}")
    
    response = await call_next(request)
    
    # Log response
    process_time = time.time() - start_time
    logger.info(f"üì§ {request.method} {request.url} - {response.status_code} - {process_time:.4f}s")
    
    return response

# Endpoint ra√≠z
@app.get(
    "/",
    tags=["root"],
    summary="Root Endpoint",
    description="Endpoint ra√≠z que proporciona informaci√≥n b√°sica de la API"
)
async def root():
    """
    Endpoint ra√≠z con informaci√≥n b√°sica de la API.
    
    Proporciona enlaces √∫tiles y estado general del sistema.
    """
    return {
        "message": f"¬°Bienvenido a {settings.PROJECT_NAME}! üöÄ",
        "version": settings.PROJECT_VERSION,
        "architecture": "Clean Architecture",
        "status": "active",
        "database": {
            "type": "MongoDB",
            "status": "connected" if mongo_client.is_connected() else "disconnected",
            "database": settings.DATABASE_NAME
        },
        "links": {
            "documentation": "/docs",
            "redoc": "/redoc",
            "api_v1": settings.API_V1_PREFIX,
            "health_check": f"{settings.API_V1_PREFIX}/health",
            "api_info": f"{settings.API_V1_PREFIX}/info"
        },
        "authentication": {
            "register": f"{settings.API_V1_PREFIX}/auth/register",
            "login": f"{settings.API_V1_PREFIX}/auth/login",
            "validate": f"{settings.API_V1_PREFIX}/auth/validate-token",
            "type": "JWT Bearer Token"
        }
    }

# Endpoint de estado detallado
@app.get(
    "/status",
    tags=["status"],
    summary="Application Status",
    description="Estado detallado de la aplicaci√≥n y sus componentes"
)
async def status():
    """
    Proporciona informaci√≥n detallada del estado de la aplicaci√≥n.
    
    Incluye estado de conexiones, configuraci√≥n y m√©tricas b√°sicas.
    """
    # Obtener estad√≠sticas de la base de datos si est√° conectada
    db_stats = {}
    if mongo_client.is_connected():
        try:
            db_stats = {
                "total_users": await mongo_client.count_users(),
                "active_users": await mongo_client.count_active_users(),
            }
        except Exception as e:
            db_stats = {"error": f"No se pudieron obtener estad√≠sticas: {str(e)}"}
    
    return {
        "application": {
            "name": settings.PROJECT_NAME,
            "version": settings.PROJECT_VERSION,
            "environment": settings.ENVIRONMENT,
            "debug": settings.DEBUG
        },
        "services": {
            "database": {
                "status": "connected" if mongo_client.is_connected() else "disconnected",
                "type": "MongoDB",
                "url": settings.MONGODB_URL,
                "database": settings.DATABASE_NAME,
                "collection": settings.USERS_COLLECTION,
                "statistics": db_stats
            },
            "authentication": {
                "status": "active",
                "type": "JWT",
                "algorithm": settings.JWT_ALGORITHM,
                "expiration_minutes": settings.JWT_EXPIRATION_TIME_MINUTES
            }
        },
        "api": {
            "version": "v1",
            "prefix": settings.API_V1_PREFIX,
            "docs": "/docs",
            "redoc": "/redoc"
        },
        "health_checks": {
            "main": f"{settings.API_V1_PREFIX}/health",
            "detailed": "/status"
        },
        "timestamp": datetime.utcnow().isoformat(),
        "uptime_status": "running"
    }

# Funci√≥n para ejecutar la aplicaci√≥n durante desarrollo
def run_dev():
    """
    Ejecuta la aplicaci√≥n en modo desarrollo.
    Solo usar para desarrollo local.
    """
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )

if __name__ == "__main__":
    run_dev()
>>>> app/use_cases/user/create_user.py
"""
Caso de uso: Crear Usuario.
Encapsula la l√≥gica de negocio para registrar un nuevo usuario.
"""
from app.domain.user.user_entity import User
from app.infrastructure.auth.password_hashing import password_hasher
from app.infrastructure.db.user_model import user_model
from app.core.utils import validation_utils
from app.core.exceptions import (
    ValidationException,
    UserAlreadyExistsException,
    InfrastructureException
)

class CreateUserUseCase:
    """
    Caso de uso para crear un nuevo usuario.
    Maneja toda la l√≥gica de negocio relacionada con el registro.
    """
    
    def __init__(self):
        self.user_model = user_model
        self.password_hasher = password_hasher
        self.validation_utils = validation_utils
    
    async def execute(self, email: str, password: str) -> User:
        """
        Ejecuta el caso de uso de creaci√≥n de usuario.
        
        Args:
            email: Email del usuario
            password: Contrase√±a en texto plano
            
        Returns:
            Entidad User creada
            
        Raises:
            ValidationException: Si hay errores de validaci√≥n de entrada
            UserAlreadyExistsException: Si el usuario ya existe
            InfrastructureException: Si hay errores de infraestructura
        """
        # Validaciones de entrada
        await self._validate_input(email, password)
        
        email = email.lower().strip()
        
        # Verificar si el usuario ya existe
        await self._check_user_not_exists(email)
        
        # Hash de la contrase√±a
        password_hash = self._hash_password(password)
        
        # Crear nueva entidad User
        new_user = User.create_new_user(
            email=email,
            password_hash=password_hash
        )
        
        # Guardar en la base de datos
        try:
            created_user = await self.user_model.create(new_user)
            return created_user
        except Exception as e:
            raise InfrastructureException(
                f"Error al crear usuario: {str(e)}", 
                "database"
            )
    
    async def _validate_input(self, email: str, password: str):
        """
        Valida los datos de entrada.
        
        Args:
            email: Email a validar
            password: Contrase√±a a validar
            
        Raises:
            ValidationException: Si hay errores de validaci√≥n
        """
        if not email or not email.strip():
            raise ValidationException("Email es requerido", "email")
        
        if not password or not password.strip():
            raise ValidationException("Contrase√±a es requerida", "password")
        
        # Validar formato del email
        if not self.validation_utils.is_valid_email(email):
            raise ValidationException("Formato de email inv√°lido", "email")
        
        # Validar contrase√±a
        if not self.validation_utils.is_valid_password(password):
            raise ValidationException(
                "La contrase√±a debe tener entre 6 y 128 caracteres", 
                "password"
            )
    
    async def _check_user_not_exists(self, email: str):
        """
        Verifica que el usuario no exista.
        
        Args:
            email: Email a verificar
            
        Raises:
            UserAlreadyExistsException: Si el usuario ya existe
        """
        existing_user = await self.user_model.get_by_email(email)
        if existing_user:
            raise UserAlreadyExistsException(email)
    
    def _hash_password(self, password: str) -> str:
        """
        Genera el hash de la contrase√±a.
        
        Args:
            password: Contrase√±a en texto plano
            
        Returns:
            Hash de la contrase√±a
            
        Raises:
            InfrastructureException: Si hay error al generar el hash
        """
        try:
            return self.password_hasher.hash_password(password)
        except Exception as e:
            raise InfrastructureException(
                f"Error al procesar contrase√±a: {str(e)}", 
                "password_hasher"
            )
    
    async def check_email_availability(self, email: str) -> bool:
        """
        Verifica si un email est√° disponible.
        
        Args:
            email: Email a verificar
            
        Returns:
            True si est√° disponible, False si ya est√° en uso
        """
        if not email or not self.validation_utils.is_valid_email(email):
            return False
        
        existing_user = await self.user_model.get_by_email(email.lower().strip())
        return existing_user is None

# Instancia del caso de uso
create_user_use_case = CreateUserUseCase()
>>>> app/use_cases/user/delete_user.py
"""
Caso de uso: Eliminar Usuario.
Encapsula la l√≥gica de negocio para eliminar usuarios.
"""
from app.domain.user.user_entity import User
from app.infrastructure.db.user_model import user_model

class DeleteUserUseCase:
    """
    Caso de uso para eliminar un usuario.
    Maneja tanto soft delete (desactivaci√≥n) como hard delete (eliminaci√≥n f√≠sica).
    """
    
    def __init__(self):
        self.user_model = user_model
    
    async def execute_soft_delete(
        self,
        user_id: str,
        requesting_user_id: str
    ) -> User:
        """
        Ejecuta un soft delete (desactivaci√≥n) del usuario.
        
        Args:
            user_id: ID del usuario a desactivar
            requesting_user_id: ID del usuario que hace la petici√≥n
            
        Returns:
            Entidad User desactivada
            
        Raises:
            ValueError: Si hay errores de validaci√≥n o permisos
        """
        # Validaciones b√°sicas
        if not user_id or not user_id.strip():
            raise ValueError("User ID es requerido")
        
        if not requesting_user_id or not requesting_user_id.strip():
            raise ValueError("Requesting user ID es requerido")
        
        # Verificar permisos: un usuario solo puede eliminar su propia cuenta
        if user_id != requesting_user_id:
            raise ValueError("No tienes permisos para eliminar este usuario")
        
        # Buscar usuario existente
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        
        if not user.is_active:
            raise ValueError("Usuario ya est√° inactivo")
        
        # Desactivar usuario (soft delete)
        user.deactivate()
        
        # Guardar cambios
        updated_user = await self.user_model.update(user)
        
        return updated_user
    
    async def execute_hard_delete(
        self,
        user_id: str,
        requesting_user_id: str
    ) -> str:
        """
        Ejecuta un hard delete (eliminaci√≥n f√≠sica) del usuario.
        
        Args:
            user_id: ID del usuario a eliminar
            requesting_user_id: ID del usuario que hace la petici√≥n
            
        Returns:
            ID del usuario eliminado
            
        Raises:
            ValueError: Si hay errores de validaci√≥n o permisos
        """
        # Validaciones b√°sicas
        if not user_id or not user_id.strip():
            raise ValueError("User ID es requerido")
        
        if not requesting_user_id or not requesting_user_id.strip():
            raise ValueError("Requesting user ID es requerido")
        
        # Verificar permisos: un usuario solo puede eliminar su propia cuenta
        if user_id != requesting_user_id:
            raise ValueError("No tienes permisos para eliminar este usuario")
        
        # Buscar usuario existente
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        
        # Eliminar usuario f√≠sicamente
        await self.user_model.delete(user_id)
        
        return user_id
    
    async def execute_by_admin_soft(self, user_id: str) -> User:
        """
        Ejecuta un soft delete como administrador.
        
        Args:
            user_id: ID del usuario a desactivar
            
        Returns:
            Entidad User desactivada
            
        Raises:
            ValueError: Si el usuario no existe
        """
        if not user_id or not user_id.strip():
            raise ValueError("User ID es requerido")
        
        # Buscar usuario existente
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        
        if not user.is_active:
            raise ValueError("Usuario ya est√° inactivo")
        
        # Desactivar usuario
        user.deactivate()
        
        # Guardar cambios
        updated_user = await self.user_model.update(user)
        
        return updated_user
    
    async def execute_by_admin_hard(self, user_id: str) -> str:
        """
        Ejecuta un hard delete como administrador.
        
        Args:
            user_id: ID del usuario a eliminar
            
        Returns:
            ID del usuario eliminado
            
        Raises:
            ValueError: Si el usuario no existe
        """
        if not user_id or not user_id.strip():
            raise ValueError("User ID es requerido")
        
        # Buscar usuario existente para validar que existe
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        
        # Eliminar usuario f√≠sicamente
        await self.user_model.delete(user_id)
        
        return user_id
    
    async def reactivate_user(
        self,
        user_id: str,
        requesting_user_id: str
    ) -> User:
        """
        Reactiva un usuario desactivado.
        
        Args:
            user_id: ID del usuario a reactivar
            requesting_user_id: ID del usuario que hace la petici√≥n
            
        Returns:
            Entidad User reactivada
            
        Raises:
            ValueError: Si hay errores de validaci√≥n o permisos
        """
        # Validaciones b√°sicas
        if not user_id or not user_id.strip():
            raise ValueError("User ID es requerido")
        
        if not requesting_user_id or not requesting_user_id.strip():
            raise ValueError("Requesting user ID es requerido")
        
        # Verificar permisos
        if user_id != requesting_user_id:
            raise ValueError("No tienes permisos para reactivar este usuario")
        
        # Buscar usuario existente
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        
        if user.is_active:
            raise ValueError("Usuario ya est√° activo")
        
        # Reactivar usuario
        user.activate()
        
        # Guardar cambios
        updated_user = await self.user_model.update(user)
        
        return updated_user

# Instancia del caso de uso
delete_user_use_case = DeleteUserUseCase()
>>>> app/use_cases/user/get_user_by_id.py
"""
Caso de uso: Obtener Usuario por ID.
Encapsula la l√≥gica de negocio para obtener un usuario espec√≠fico.
"""
from typing import Optional
from app.domain.user.user_entity import User
from app.infrastructure.db.user_model import user_model
from app.core.exceptions import (
    ValidationException,
    UserNotFoundException,
    AuthorizationException,
    UserInactiveException
)

class GetUserByIdUseCase:
    """
    Caso de uso para obtener un usuario por su ID.
    Incluye validaciones de negocio y permisos apropiados.
    """
    
    def __init__(self):
        self.user_model = user_model
    
    async def execute(self, user_id: str, requesting_user_id: str) -> User:
        """
        Ejecuta el caso de uso de obtener usuario por ID.
        
        Args:
            user_id: ID del usuario a obtener
            requesting_user_id: ID del usuario que hace la petici√≥n
            
        Returns:
            Entidad User encontrada
            
        Raises:
            ValidationException: Si hay errores de validaci√≥n
            UserNotFoundException: Si el usuario no existe
            UserInactiveException: Si el usuario est√° inactivo
        """
        # Validaciones b√°sicas
        if not user_id or not user_id.strip():
            raise ValidationException("User ID es requerido", "user_id")
        
        if not requesting_user_id or not requesting_user_id.strip():
            raise ValidationException("Requesting user ID es requerido", "requesting_user_id")
        
        # Verificar que el usuario solicitante existe y est√° activo
        requesting_user = await self.user_model.get_by_id(requesting_user_id)
        if not requesting_user:
            raise AuthorizationException("Usuario solicitante no encontrado")
        
        if not requesting_user.is_active:
            raise UserInactiveException(requesting_user_id)
        
        # Buscar el usuario solicitado
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise UserNotFoundException(user_id)
        
        # Verificar que el usuario solicitado est√© activo
        if not user.is_active:
            raise UserNotFoundException(user_id)  # Por seguridad, no revelamos que existe pero est√° inactivo
        
        # Permitir acceso a informaci√≥n b√°sica de usuarios activos
        # En una API p√∫blica, los usuarios pueden ver perfiles b√°sicos de otros usuarios
        # Si se necesita informaci√≥n m√°s sensible, se podr√≠a agregar l√≥gica de permisos aqu√≠
        
        return user
    
    async def execute_own_profile(self, user_id: str) -> User:
        """
        Ejecuta el caso de uso para obtener el perfil propio del usuario.
        √ötil para el endpoint /me/profile.
        
        Args:
            user_id: ID del usuario
            
        Returns:
            Entidad User encontrada
            
        Raises:
            ValidationException: Si hay errores de validaci√≥n
            UserNotFoundException: Si el usuario no existe
            UserInactiveException: Si el usuario est√° inactivo
        """
        if not user_id or not user_id.strip():
            raise ValidationException("User ID es requerido", "user_id")
        
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise UserNotFoundException(user_id)
        
        if not user.is_active:
            raise UserInactiveException(user_id)
        
        return user
    
    async def execute_by_admin(self, user_id: str) -> User:
        """
        Ejecuta el caso de uso como administrador (sin restricciones de permisos).
        √ötil para casos internos del sistema o funciones administrativas.
        
        Args:
            user_id: ID del usuario a obtener
            
        Returns:
            Entidad User encontrada (incluso si est√° inactivo)
            
        Raises:
            ValidationException: Si hay errores de validaci√≥n
            UserNotFoundException: Si el usuario no existe
        """
        if not user_id or not user_id.strip():
            raise ValidationException("User ID es requerido", "user_id")
        
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise UserNotFoundException(user_id)
        
        return user

# Instancia del caso de uso
get_user_by_id_use_case = GetUserByIdUseCase()
>>>> app/use_cases/user/list_users.py
"""
Caso de uso: Listar Usuarios.
Encapsula la l√≥gica de negocio para obtener una lista paginada de usuarios.
"""
from typing import List, Tuple
from app.domain.user.user_entity import User
from app.infrastructure.db.user_model import user_model
from app.core.exceptions import (
    ValidationException,
    AuthorizationException,
    UserInactiveException,
    UserNotFoundException
)

class ListUsersUseCase:
    """
    Caso de uso para listar usuarios con paginaci√≥n.
    Incluye validaciones y l√≥gica de permisos.
    """
    
    def __init__(self):
        self.user_model = user_model
    
    async def execute(
        self, 
        requesting_user_id: str,
        skip: int = 0, 
        limit: int = 20
    ) -> Tuple[List[User], int]:
        """
        Ejecuta el caso de uso de listar usuarios.
        
        Args:
            requesting_user_id: ID del usuario que hace la petici√≥n
            skip: N√∫mero de registros a saltar
            limit: L√≠mite de registros a retornar
            
        Returns:
            Tupla con (lista_usuarios, total_usuarios)
            
        Raises:
            ValidationException: Si hay errores de validaci√≥n
            AuthorizationException: Si no tiene permisos
            UserInactiveException: Si el usuario est√° inactivo
        """
        # Validaciones b√°sicas
        if not requesting_user_id or not requesting_user_id.strip():
            raise ValidationException("Requesting user ID es requerido", "requesting_user_id")
        
        if skip < 0:
            raise ValidationException("Skip debe ser mayor o igual a 0", "skip")
        
        if limit < 1 or limit > 100:
            raise ValidationException("Limit debe estar entre 1 y 100", "limit")
        
        # Verificar que el usuario solicitante existe y est√° activo
        requesting_user = await self.user_model.get_by_id(requesting_user_id)
        if not requesting_user:
            raise AuthorizationException("Usuario solicitante no encontrado")
        
        if not requesting_user.is_active:
            raise UserInactiveException(requesting_user_id)
        
        # Por ahora, cualquier usuario autenticado puede listar usuarios
        # En una implementaci√≥n m√°s compleja, esto podr√≠a estar restringido a admins
        
        # Obtener usuarios
        users = await self.user_model.get_all(skip=skip, limit=limit)
        
        # Filtrar solo usuarios activos (para usuarios normales)
        # En una implementaci√≥n con roles, los admins podr√≠an ver todos
        active_users = [user for user in users if user.is_active]
        
        # Obtener total de usuarios activos usando la funci√≥n optimizada
        total_users = await self._count_active_users()
        
        return active_users, total_users
    
    async def execute_by_admin(
        self, 
        skip: int = 0, 
        limit: int = 20,
        include_inactive: bool = False
    ) -> Tuple[List[User], int]:
        """
        Ejecuta el caso de uso como administrador (sin restricciones).
        
        Args:
            skip: N√∫mero de registros a saltar
            limit: L√≠mite de registros a retornar
            include_inactive: Si incluir usuarios inactivos
            
        Returns:
            Tupla con (lista_usuarios, total_usuarios)
            
        Raises:
            ValidationException: Si hay errores de validaci√≥n
        """
        if skip < 0:
            raise ValidationException("Skip debe ser mayor o igual a 0", "skip")
        
        if limit < 1 or limit > 100:
            raise ValidationException("Limit debe estar entre 1 y 100", "limit")
        
        # Obtener todos los usuarios
        all_users = await self.user_model.get_all(skip=skip, limit=limit)
        
        if include_inactive:
            users = all_users
            total = await self.user_model.count()
        else:
            users = [user for user in all_users if user.is_active]
            total = await self._count_active_users()
        
        return users, total
    
    async def _count_active_users(self) -> int:
        """
        Cuenta el n√∫mero de usuarios activos usando la nueva funci√≥n optimizada.
        
        Returns:
            N√∫mero de usuarios activos
        """
        return await self.user_model.count_active()

# Instancia del caso de uso
list_users_use_case = ListUsersUseCase()
>>>> app/use_cases/user/login_user.py
"""
Caso de uso: Login de Usuario.
Encapsula la l√≥gica de negocio para autenticaci√≥n de usuarios.
"""
from typing import Tuple
from app.domain.user.user_entity import User
from app.infrastructure.auth.password_hashing import password_hasher
from app.infrastructure.auth.jwt_handler import jwt_handler
from app.infrastructure.db.user_model import user_model
from app.core.utils import validation_utils
from app.core.exceptions import (
    ValidationException,
    InvalidCredentialsException,
    UserInactiveException,
    UserNotFoundException
)

class LoginUserUseCase:
    """
    Caso de uso para autenticaci√≥n de usuario.
    Maneja la validaci√≥n de credenciales y generaci√≥n de tokens.
    """
    
    def __init__(self):
        self.user_model = user_model
        self.password_hasher = password_hasher
        self.jwt_handler = jwt_handler
        self.validation_utils = validation_utils
    
    async def execute(self, email: str, password: str) -> Tuple[str, User]:
        """
        Ejecuta el caso de uso de login de usuario.
        
        Args:
            email: Email del usuario
            password: Contrase√±a en texto plano
            
        Returns:
            Tupla con (token_jwt, entidad_user)
            
        Raises:
            ValidationException: Si los datos de entrada son inv√°lidos
            InvalidCredentialsException: Si las credenciales son incorrectas
            UserInactiveException: Si el usuario est√° inactivo
        """
        # Validaciones de entrada
        if not email or not email.strip():
            raise ValidationException("Email es requerido", "email")
        
        if not password or not password.strip():
            raise ValidationException("Contrase√±a es requerida", "password")
        
        # Validar formato del email
        if not self.validation_utils.is_valid_email(email):
            raise ValidationException("Formato de email inv√°lido", "email")
        
        email = email.lower().strip()
        
        # Buscar usuario por email
        user = await self.user_model.get_by_email(email)
        if not user:
            # Por seguridad, no revelamos si el email existe o no
            raise InvalidCredentialsException()
        
        # Verificar si el usuario est√° activo
        if not user.is_active:
            raise UserInactiveException(user.id)
        
        # Verificar contrase√±a
        is_valid_password = self.password_hasher.verify_password(
            password, user.password_hash
        )
        if not is_valid_password:
            raise InvalidCredentialsException()
        
        # Generar token JWT
        access_token = self.jwt_handler.create_access_token(
            user_id=user.id,
            email=user.email
        )
        
        return access_token, user
    
    async def validate_credentials(self, email: str, password: str) -> bool:
        """
        Valida credenciales sin generar token.
        √ötil para validaciones internas.
        
        Args:
            email: Email del usuario
            password: Contrase√±a en texto plano
            
        Returns:
            True si las credenciales son v√°lidas, False en caso contrario
        """
        try:
            await self.execute(email, password)
            return True
        except (InvalidCredentialsException, UserInactiveException, ValidationException):
            return False

# Instancia del caso de uso
login_user_use_case = LoginUserUseCase()
>>>> app/use_cases/user/update_user.py
"""
Caso de uso: Actualizar Usuario.
Encapsula la l√≥gica de negocio para actualizar informaci√≥n de usuario.
"""
from typing import Optional
from app.domain.user.user_entity import User
from app.infrastructure.auth.password_hashing import password_hasher
from app.infrastructure.db.user_model import user_model
from app.core.utils import validation_utils
from app.core.exceptions import (
    ValidationException,
    UserNotFoundException,
    AuthorizationException,
    UserInactiveException,
    ConflictException,
    BusinessRuleException
)

class UpdateUserUseCase:
    """
    Caso de uso para actualizar un usuario existente.
    Maneja validaciones, permisos y l√≥gica de negocio.
    """
    
    def __init__(self):
        self.user_model = user_model
        self.password_hasher = password_hasher
        self.validation_utils = validation_utils
    
    async def execute(
        self,
        user_id: str,
        requesting_user_id: str,
        new_email: Optional[str] = None,
        new_password: Optional[str] = None
    ) -> User:
        """
        Ejecuta el caso de uso de actualizaci√≥n de usuario.
        
        Args:
            user_id: ID del usuario a actualizar
            requesting_user_id: ID del usuario que hace la petici√≥n
            new_email: Nuevo email (opcional)
            new_password: Nueva contrase√±a (opcional)
            
        Returns:
            Entidad User actualizada
            
        Raises:
            ValidationException: Si hay errores de validaci√≥n
            UserNotFoundException: Si el usuario no existe
            AuthorizationException: Si no tiene permisos
            UserInactiveException: Si el usuario est√° inactivo
            ConflictException: Si el email ya est√° en uso
            BusinessRuleException: Si viola reglas de negocio
        """
        # Validaciones b√°sicas
        if not user_id or not user_id.strip():
            raise ValidationException("User ID es requerido", "user_id")
        
        if not requesting_user_id or not requesting_user_id.strip():
            raise ValidationException("Requesting user ID es requerido", "requesting_user_id")
        
        # Verificar que hay algo que actualizar
        if not new_email and not new_password:
            raise BusinessRuleException("Debe proporcionar al menos un campo para actualizar", "update_fields_required")
        
        # Verificar que el usuario solicitante existe y est√° activo
        requesting_user = await self.user_model.get_by_id(requesting_user_id)
        if not requesting_user:
            raise AuthorizationException("Usuario solicitante no encontrado")
        
        if not requesting_user.is_active:
            raise UserInactiveException(requesting_user_id)
        
        # Verificar permisos: un usuario solo puede actualizar su propia informaci√≥n
        if user_id != requesting_user_id:
            raise AuthorizationException("No tienes permisos para actualizar este usuario")
        
        # Buscar usuario existente
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise UserNotFoundException(user_id)
        
        if not user.is_active:
            raise UserInactiveException(user_id)
        
        # Validar y actualizar email si se proporciona
        if new_email:
            await self._update_user_email(user, new_email)
        
        # Validar y actualizar contrase√±a si se proporciona
        if new_password:
            await self._update_user_password(user, new_password)
        
        # Guardar cambios
        updated_user = await self.user_model.update(user)
        
        return updated_user
    
    async def _update_user_email(self, user: User, new_email: str):
        """
        Actualiza el email del usuario con validaciones.
        
        Args:
            user: Entidad User a actualizar
            new_email: Nuevo email
            
        Raises:
            ValidationException: Si el email es inv√°lido
            ConflictException: Si el email ya est√° en uso
        """
        # Validar formato del email
        if not self.validation_utils.is_valid_email(new_email):
            raise ValidationException("El formato del email es inv√°lido", "email")
        
        new_email = new_email.lower().strip()
        
        # Verificar que el email no est√© en uso por otro usuario
        existing_user = await self.user_model.get_by_email(new_email)
        if existing_user and existing_user.id != user.id:
            raise ConflictException(f"El email {new_email} ya est√° en uso por otro usuario", "User")
        
        # Actualizar email en la entidad
        user.update_email(new_email)
    
    async def _update_user_password(self, user: User, new_password: str):
        """
        Actualiza la contrase√±a del usuario con validaciones.
        
        Args:
            user: Entidad User a actualizar
            new_password: Nueva contrase√±a
            
        Raises:
            ValidationException: Si la contrase√±a no cumple los requisitos
        """
        # Validar contrase√±a
        if not self.validation_utils.is_valid_password(new_password):
            raise ValidationException("La contrase√±a debe tener entre 6 y 128 caracteres", "password")
        
        # Generar nuevo hash
        new_password_hash = self.password_hasher.hash_password(new_password)
        
        # Actualizar contrase√±a en la entidad
        user.update_password_hash(new_password_hash)
    
    async def execute_by_admin(
        self,
        user_id: str,
        new_email: Optional[str] = None,
        new_password: Optional[str] = None,
        is_active: Optional[bool] = None
    ) -> User:
        """
        Ejecuta el caso de uso como administrador (sin restricciones de permisos).
        
        Args:
            user_id: ID del usuario a actualizar
            new_email: Nuevo email (opcional)
            new_password: Nueva contrase√±a (opcional)
            is_active: Nuevo estado activo (opcional)
            
        Returns:
            Entidad User actualizada
            
        Raises:
            ValidationException: Si hay errores de validaci√≥n
            UserNotFoundException: Si el usuario no existe
            ConflictException: Si el email ya est√° en uso
            BusinessRuleException: Si viola reglas de negocio
        """
        if not user_id or not user_id.strip():
            raise ValidationException("User ID es requerido", "user_id")
        
        # Verificar que hay algo que actualizar
        if not new_email and not new_password and is_active is None:
            raise BusinessRuleException("Debe proporcionar al menos un campo para actualizar", "update_fields_required")
        
        # Buscar usuario existente
        user = await self.user_model.get_by_id(user_id)
        if not user:
            raise UserNotFoundException(user_id)
        
        # Actualizar email si se proporciona
        if new_email:
            await self._update_user_email(user, new_email)
        
        # Actualizar contrase√±a si se proporciona
        if new_password:
            await self._update_user_password(user, new_password)
        
        # Actualizar estado activo si se proporciona
        if is_active is not None:
            if is_active:
                user.activate()
            else:
                user.deactivate()
        
        # Guardar cambios
        updated_user = await self.user_model.update(user)
        
        return updated_user

# Instancia del caso de uso
update_user_use_case = UpdateUserUseCase()
>>>> docker-compose.yml
version: '3.8'

services:
  mongodb:
    image: mongo:7.0
    container_name: clients_api_mongodb
    restart: always
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: password123
      MONGO_INITDB_DATABASE: clients_db
    volumes:
      - mongodb_data:/data/db
      - ./docker/mongo-init.js:/docker-entrypoint-initdb.d/mongo-init.js:ro
    networks:
      - clients_api_network

  # Opcional: MongoDB Express para administraci√≥n web
  mongo-express:
    image: mongo-express:1.0.0
    container_name: clients_api_mongo_express
    restart: always
    ports:
      - "8081:8081"
    environment:
      ME_CONFIG_MONGODB_ADMINUSERNAME: admin
      ME_CONFIG_MONGODB_ADMINPASSWORD: password123
      ME_CONFIG_MONGODB_URL: mongodb://admin:password123@mongodb:27017/
      ME_CONFIG_BASICAUTH: false
    depends_on:
      - mongodb
    networks:
      - clients_api_network

volumes:
  mongodb_data:
    driver: local

networks:
  clients_api_network:
    driver: bridge
>>>> docker/mongo-init.js
// Inicializaci√≥n de la base de datos MongoDB para Clients API
print('üöÄ Iniciando configuraci√≥n de MongoDB para Clients API...');

// Cambiar a la base de datos clients_db
db = db.getSiblingDB('clients_db');

// Crear colecci√≥n de usuarios
db.createCollection('users');

// Crear √≠ndices para optimizar consultas
print('üìä Creando √≠ndices...');

// √çndice √∫nico en email
db.users.createIndex(
    { "email": 1 }, 
    { 
        unique: true, 
        name: "idx_users_email_unique",
        background: true 
    }
);

// √çndice en is_active para consultas de usuarios activos
db.users.createIndex(
    { "is_active": 1 }, 
    { 
        name: "idx_users_is_active",
        background: true 
    }
);

// √çndice compuesto para b√∫squedas eficientes
db.users.createIndex(
    { "is_active": 1, "email": 1 }, 
    { 
        name: "idx_users_active_email",
        background: true 
    }
);

// √çndice en created_at para ordenamiento temporal
db.users.createIndex(
    { "created_at": -1 }, 
    { 
        name: "idx_users_created_at",
        background: true 
    }
);

print('‚úÖ √çndices creados exitosamente');

// Verificar √≠ndices creados
print('üìã √çndices en la colecci√≥n users:');
db.users.getIndexes().forEach(function(index) {
    print('  - ' + index.name + ': ' + JSON.stringify(index.key));
});

// Insertar usuario de prueba (opcional para desarrollo)
print('üë§ Creando usuario de prueba...');

const testUser = {
    "id": "test-user-uuid-12345",
    "email": "test@example.com",
    "password_hash": "$2b$12$vQE.L8yKz8ZjLGvOd5j5Z.K8QZGqXjK9Z1OqQoV8LGGqLOqOLGLOL", // password: "test123"
    "is_active": true,
    "created_at": new Date().toISOString(),
    "updated_at": new Date().toISOString()
};

try {
    db.users.insertOne(testUser);
    print('‚úÖ Usuario de prueba creado: test@example.com / test123');
} catch (error) {
    if (error.code === 11000) {
        print('‚ÑπÔ∏è Usuario de prueba ya existe');
    } else {
        print('‚ùå Error al crear usuario de prueba: ' + error.message);
    }
}

// Verificar configuraci√≥n
print('üîç Verificando configuraci√≥n...');
print('üìä Total de usuarios: ' + db.users.countDocuments({}));
print('üìä Usuarios activos: ' + db.users.countDocuments({"is_active": true}));

print('‚úÖ Configuraci√≥n de MongoDB completada exitosamente');
print('üåê La base de datos clients_db est√° lista para usar');
print('üîó Conexi√≥n: mongodb://localhost:27017/clients_db');
print('üõ†Ô∏è Administraci√≥n web: http://localhost:8081 (si est√° habilitado)');
>>>> requirements.txt
# FastAPI y servidor
fastapi==0.103.2
uvicorn[standard]==0.23.2

# Validaci√≥n y serializaci√≥n
pydantic==1.10.13  # √öltima versi√≥n estable de Pydantic v1 compatible con m√°s herramientas

# Autenticaci√≥n y seguridad
PyJWT==2.8.0
python-jose[cryptography]==3.3.0
bcrypt==4.1.2
passlib[bcrypt]==1.7.4

# Base de datos MongoDB
motor==3.3.2  # Driver as√≠ncrono de MongoDB para Python
pymongo==4.6.0  # Driver s√≠ncrono de MongoDB (dependency de motor)

# Utilidades
python-multipart==0.0.6
email-validator==1.3.1  # Versi√≥n estable y no yankeada

# Desarrollo y testing
pytest==7.4.3
pytest-asyncio==0.21.1
httpx==0.25.2

>>>> tests/integration/test_user_endpoints.py

>>>> tests/unit/test_entities.py

>>>> tests/unit/test_use_cases.py
